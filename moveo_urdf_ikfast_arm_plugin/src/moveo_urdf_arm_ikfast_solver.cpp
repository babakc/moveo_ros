/// autogenerated analytical inverse kinematics code from ikfast program part of OpenRAVE
/// \author Rosen Diankov
///
/// Licensed under the Apache License, Version 2.0 (the "License");
/// you may not use this file except in compliance with the License.
/// You may obtain a copy of the License at
///     http://www.apache.org/licenses/LICENSE-2.0
/// 
/// Unless required by applicable law or agreed to in writing, software
/// distributed under the License is distributed on an "AS IS" BASIS,
/// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
/// See the License for the specific language governing permissions and
/// limitations under the License.
///
/// ikfast version 0x1000004a generated on 2019-03-16 17:22:31.723633
/// To compile with gcc:
///     gcc -lstdc++ ik.cpp
/// To compile without any main function as a shared object (might need -llapack):
///     gcc -fPIC -lstdc++ -DIKFAST_NO_MAIN -DIKFAST_CLIBRARY -shared -Wl,-soname,libik.so -o libik.so ik.cpp
#define IKFAST_HAS_LIBRARY
#include "ikfast.h" // found inside share/openrave-X.Y/python/ikfast.h
using namespace ikfast;

// check if the included ikfast version matches what this file was compiled with
#define IKFAST_COMPILE_ASSERT(x) extern int __dummy[(int)x]
IKFAST_COMPILE_ASSERT(IKFAST_VERSION==0x1000004a);

#include <cmath>
#include <vector>
#include <limits>
#include <algorithm>
#include <complex>

#ifndef IKFAST_ASSERT
#include <stdexcept>
#include <sstream>
#include <iostream>

#ifdef _MSC_VER
#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __FUNCDNAME__
#endif
#endif

#ifndef __PRETTY_FUNCTION__
#define __PRETTY_FUNCTION__ __func__
#endif

#define IKFAST_ASSERT(b) { if( !(b) ) { std::stringstream ss; ss << "ikfast exception: " << __FILE__ << ":" << __LINE__ << ": " <<__PRETTY_FUNCTION__ << ": Assertion '" << #b << "' failed"; throw std::runtime_error(ss.str()); } }

#endif

#if defined(_MSC_VER)
#define IKFAST_ALIGNED16(x) __declspec(align(16)) x
#else
#define IKFAST_ALIGNED16(x) x __attribute((aligned(16)))
#endif

#define IK2PI  ((IkReal)6.28318530717959)
#define IKPI  ((IkReal)3.14159265358979)
#define IKPI_2  ((IkReal)1.57079632679490)

#ifdef _MSC_VER
#ifndef isnan
#define isnan _isnan
#endif
#ifndef isinf
#define isinf _isinf
#endif
//#ifndef isfinite
//#define isfinite _isfinite
//#endif
#endif // _MSC_VER

// lapack routines
extern "C" {
  void dgetrf_ (const int* m, const int* n, double* a, const int* lda, int* ipiv, int* info);
  void zgetrf_ (const int* m, const int* n, std::complex<double>* a, const int* lda, int* ipiv, int* info);
  void dgetri_(const int* n, const double* a, const int* lda, int* ipiv, double* work, const int* lwork, int* info);
  void dgesv_ (const int* n, const int* nrhs, double* a, const int* lda, int* ipiv, double* b, const int* ldb, int* info);
  void dgetrs_(const char *trans, const int *n, const int *nrhs, double *a, const int *lda, int *ipiv, double *b, const int *ldb, int *info);
  void dgeev_(const char *jobvl, const char *jobvr, const int *n, double *a, const int *lda, double *wr, double *wi,double *vl, const int *ldvl, double *vr, const int *ldvr, double *work, const int *lwork, int *info);
}

using namespace std; // necessary to get std math routines

#ifdef IKFAST_NAMESPACE
namespace IKFAST_NAMESPACE {
#endif

inline float IKabs(float f) { return fabsf(f); }
inline double IKabs(double f) { return fabs(f); }

inline float IKsqr(float f) { return f*f; }
inline double IKsqr(double f) { return f*f; }

inline float IKlog(float f) { return logf(f); }
inline double IKlog(double f) { return log(f); }

// allows asin and acos to exceed 1. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_SINCOS_THRESH
#define IKFAST_SINCOS_THRESH ((IkReal)1e-7)
#endif

// used to check input to atan2 for degenerate cases. has to be smaller than thresholds used for branch conds and evaluation
#ifndef IKFAST_ATAN2_MAGTHRESH
#define IKFAST_ATAN2_MAGTHRESH ((IkReal)1e-7)
#endif

// minimum distance of separate solutions
#ifndef IKFAST_SOLUTION_THRESH
#define IKFAST_SOLUTION_THRESH ((IkReal)1e-6)
#endif

// there are checkpoints in ikfast that are evaluated to make sure they are 0. This threshold speicfies by how much they can deviate
#ifndef IKFAST_EVALCOND_THRESH
#define IKFAST_EVALCOND_THRESH ((IkReal)0.00001)
#endif


inline float IKasin(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(-IKPI_2);
else if( f >= 1 ) return float(IKPI_2);
return asinf(f);
}
inline double IKasin(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return -IKPI_2;
else if( f >= 1 ) return IKPI_2;
return asin(f);
}

// return positive value in [0,y)
inline float IKfmod(float x, float y)
{
    while(x < 0) {
        x += y;
    }
    return fmodf(x,y);
}

// return positive value in [0,y)
inline double IKfmod(double x, double y)
{
    while(x < 0) {
        x += y;
    }
    return fmod(x,y);
}

inline float IKacos(float f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return float(IKPI);
else if( f >= 1 ) return float(0);
return acosf(f);
}
inline double IKacos(double f)
{
IKFAST_ASSERT( f > -1-IKFAST_SINCOS_THRESH && f < 1+IKFAST_SINCOS_THRESH ); // any more error implies something is wrong with the solver
if( f <= -1 ) return IKPI;
else if( f >= 1 ) return 0;
return acos(f);
}
inline float IKsin(float f) { return sinf(f); }
inline double IKsin(double f) { return sin(f); }
inline float IKcos(float f) { return cosf(f); }
inline double IKcos(double f) { return cos(f); }
inline float IKtan(float f) { return tanf(f); }
inline double IKtan(double f) { return tan(f); }
inline float IKsqrt(float f) { if( f <= 0.0f ) return 0.0f; return sqrtf(f); }
inline double IKsqrt(double f) { if( f <= 0.0 ) return 0.0; return sqrt(f); }
inline float IKatan2Simple(float fy, float fx) {
    return atan2f(fy,fx);
}
inline float IKatan2(float fy, float fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return float(IKPI_2);
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2f(fy,fx);
}
inline double IKatan2Simple(double fy, double fx) {
    return atan2(fy,fx);
}
inline double IKatan2(double fy, double fx) {
    if( isnan(fy) ) {
        IKFAST_ASSERT(!isnan(fx)); // if both are nan, probably wrong value will be returned
        return IKPI_2;
    }
    else if( isnan(fx) ) {
        return 0;
    }
    return atan2(fy,fx);
}

template <typename T>
struct CheckValue
{
    T value;
    bool valid;
};

template <typename T>
inline CheckValue<T> IKatan2WithCheck(T fy, T fx, T epsilon)
{
    CheckValue<T> ret;
    ret.valid = false;
    ret.value = 0;
    if( !isnan(fy) && !isnan(fx) ) {
        if( IKabs(fy) >= IKFAST_ATAN2_MAGTHRESH || IKabs(fx) > IKFAST_ATAN2_MAGTHRESH ) {
            ret.value = IKatan2Simple(fy,fx);
            ret.valid = true;
        }
    }
    return ret;
}

inline float IKsign(float f) {
    if( f > 0 ) {
        return float(1);
    }
    else if( f < 0 ) {
        return float(-1);
    }
    return 0;
}

inline double IKsign(double f) {
    if( f > 0 ) {
        return 1.0;
    }
    else if( f < 0 ) {
        return -1.0;
    }
    return 0;
}

template <typename T>
inline CheckValue<T> IKPowWithIntegerCheck(T f, int n)
{
    CheckValue<T> ret;
    ret.valid = true;
    if( n == 0 ) {
        ret.value = 1.0;
        return ret;
    }
    else if( n == 1 )
    {
        ret.value = f;
        return ret;
    }
    else if( n < 0 )
    {
        if( f == 0 )
        {
            ret.valid = false;
            ret.value = (T)1.0e30;
            return ret;
        }
        if( n == -1 ) {
            ret.value = T(1.0)/f;
            return ret;
        }
    }

    int num = n > 0 ? n : -n;
    if( num == 2 ) {
        ret.value = f*f;
    }
    else if( num == 3 ) {
        ret.value = f*f*f;
    }
    else {
        ret.value = 1.0;
        while(num>0) {
            if( num & 1 ) {
                ret.value *= f;
            }
            num >>= 1;
            f *= f;
        }
    }
    
    if( n < 0 ) {
        ret.value = T(1.0)/ret.value;
    }
    return ret;
}

/// solves the forward kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API void ComputeFk(const IkReal* j, IkReal* eetrans, IkReal* eerot) {
IkReal x0,x1,x2,x3,x4,x5,x6,x7,x8,x9,x10,x11,x12,x13,x14,x15,x16,x17,x18,x19,x20,x21,x22,x23,x24,x25,x26,x27,x28,x29,x30,x31,x32,x33,x34,x35,x36,x37,x38,x39,x40,x41,x42,x43,x44,x45;
x0=IKcos(j[2]);
x1=IKsin(j[0]);
x2=IKsin(j[1]);
x3=IKcos(j[1]);
x4=IKsin(j[2]);
x5=IKcos(j[0]);
x6=IKsin(j[3]);
x7=IKcos(j[3]);
x8=IKsin(j[4]);
x9=IKcos(j[4]);
x10=((0.996194327226083)*x7);
x11=((0.0871599816577085)*x7);
x12=((0.225)*x5);
x13=((0.002)*x5);
x14=((0.996194327226083)*x9);
x15=((0.00082188)*x5);
x16=((0.0871599816577085)*x8);
x17=((0.996194327226083)*x6);
x18=((0.00082188)*x1);
x19=((0.0871599816577085)*x9);
x20=((0.22)*x2);
x21=((0.996194327226083)*x8);
x22=((0.00207955)*x1);
x23=((0.00207955)*x5);
x24=((0.996194327226083)*x5);
x25=((0.002)*x1);
x26=((0.0871599816577085)*x1);
x27=((0.0871599816577085)*x5);
x28=(x3*x4);
x29=(x2*x4);
x30=(x0*x2);
x31=(x0*x3);
x32=((-0.0871599816577085)*x6);
x33=((-0.0871599816577085)*x7);
x34=((-0.996194327226083)*x5);
x35=((0.996194327226083)*x29);
x36=((0.996194327226083)*x31);
x37=(x1*x30);
x38=((((0.0871599816577085)*x28))+(((0.0871599816577085)*x30)));
x39=(x1*(((((-1.0)*x31))+x29)));
x40=(x5*(((((-1.0)*x29))+x31)));
x41=(x38*x7);
x42=(x39*x7);
x43=(((x7*(((((0.996194327226083)*x30))+(((0.996194327226083)*x28))))))+(((0.0871599816577085)*x31))+(((-0.0871599816577085)*x29)));
x44=(((x10*x39))+(((-1.0)*x17*x5))+((x26*((x30+x28)))));
x45=(((x10*x40))+(((-1.0)*x1*x17))+((x27*(((((-1.0)*x30))+(((-1.0)*x28)))))));
IkReal x46=((1.0)*x29);
eetrans[0]=(((x1*x20))+((x6*(((((-1.0)*x22*x46))+((x22*x31))))))+(((0.225)*x37))+(((0.225)*x1*x28))+(((-1.0)*x25*x46))+(((0.001)*x5))+(((-1.0)*x15*x6))+((x25*x31))+(((-1.0)*x23*x7))+((x7*((((x18*x29))+(((-1.0)*x18*x31)))))));
IkReal x47=((1.0)*x31);
IkReal x48=((1.0)*x12);
eetrans[1]=((((-1.0)*x30*x48))+(((-1.0)*x28*x48))+(((-1.0)*x18*x6))+(((-1.0)*x22*x7))+(((-1.0)*x20*x5))+(((0.001)*x1))+((x6*(((((-1.0)*x23*x47))+((x23*x29))))))+((x13*x29))+(((-1.0)*x13*x47))+((x7*(((((-1.0)*x15*x29))+((x15*x31)))))));
eetrans[2]=((0.313)+(((0.22)*x3))+((x6*(((((-0.00207955)*x28))+(((-0.00207955)*x30))))))+(((-0.002)*x28))+(((-0.225)*x29))+(((0.225)*x31))+(((-0.002)*x30))+((x7*(((((0.00082188)*x30))+(((0.00082188)*x28)))))));
IkReal x49=((0.996194327226083)*x37);
IkReal x50=((0.996194327226083)*x1*x28);
IkReal x51=(x49+x50);
eerot[0]=(((x19*x44))+(((-1.0)*x14*((((x32*x5))+((x11*x39))+(((-1.0)*x51))))))+(((-1.0)*x21*x44))+((x16*((((x27*x6))+x51+((x33*x39)))))));
eerot[1]=(((x19*x45))+((x16*((((x28*x34))+((x30*x34))+((x26*x6))+((x33*x40))))))+(((-1.0)*x21*x45))+(((-1.0)*x14*((((x11*x40))+((x1*x32))+((x24*x30))+((x24*x28)))))));
eerot[2]=(((x19*x43))+((x16*(((((-1.0)*x35))+(((-1.0)*x41))+x36))))+(((-1.0)*x21*x43))+(((-1.0)*x14*(((((-1.0)*x36))+x35+x41)))));
}

IKFAST_API int GetNumFreeParameters() { return 0; }
IKFAST_API int* GetFreeParameters() { return NULL; }
IKFAST_API int GetNumJoints() { return 5; }

IKFAST_API int GetIkRealSize() { return sizeof(IkReal); }

IKFAST_API int GetIkType() { return 0x56000007; }

class IKSolver {
public:
IkReal j0,cj0,sj0,htj0,j0mul,j1,cj1,sj1,htj1,j1mul,j2,cj2,sj2,htj2,j2mul,j3,cj3,sj3,htj3,j3mul,j4,cj4,sj4,htj4,j4mul,new_r00,r00,rxp0_0,new_r01,r01,rxp0_1,new_r02,r02,rxp0_2,new_px,px,npx,new_py,py,npy,new_pz,pz,npz,pp;
unsigned char _ij0[2], _nj0,_ij1[2], _nj1,_ij2[2], _nj2,_ij3[2], _nj3,_ij4[2], _nj4;

IkReal j100, cj100, sj100;
unsigned char _ij100[2], _nj100;
bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
j0=numeric_limits<IkReal>::quiet_NaN(); _ij0[0] = -1; _ij0[1] = -1; _nj0 = -1; j1=numeric_limits<IkReal>::quiet_NaN(); _ij1[0] = -1; _ij1[1] = -1; _nj1 = -1; j2=numeric_limits<IkReal>::quiet_NaN(); _ij2[0] = -1; _ij2[1] = -1; _nj2 = -1; j3=numeric_limits<IkReal>::quiet_NaN(); _ij3[0] = -1; _ij3[1] = -1; _nj3 = -1; j4=numeric_limits<IkReal>::quiet_NaN(); _ij4[0] = -1; _ij4[1] = -1; _nj4 = -1; 
for(int dummyiter = 0; dummyiter < 1; ++dummyiter) {
    solutions.Clear();
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];

r00 = eerot[0];
r01 = eerot[1];
r02 = eerot[2];
px = eetrans[0]; py = eetrans[1]; pz = eetrans[2];
new_r00=r00;
new_px=px;
new_r01=r01;
new_py=py;
new_r02=r02;
new_pz=((-0.313)+pz);
r00 = new_r00; r01 = new_r01; r02 = new_r02; px = new_px; py = new_py; pz = new_pz;

pp=((px*px)+(py*py)+(pz*pz));
IkReal op[72], zeror[48];
int numroots;;
IkReal x52=((0.004)*py);
IkReal x53=((0.002)*px);
IkReal x54=((0.44)*pz);
IkReal x55=((0.004)*pz);
IkReal x56=((0.008)*py);
IkReal x57=((0.008)*pz);
IkReal x58=((0.88)*py);
IkReal x59=pz*pz;
IkReal x60=py*py;
IkReal x61=px*px;
IkReal x62=((0.0022249999850631)*r02);
IkReal x63=((0.00105784905388185)*r01);
IkReal x64=((8.43018922363011e-5)*r00);
IkReal x65=((3.95220119737443e-6)*r02);
IkReal x66=((9.88050889679949e-6)*r00);
IkReal x67=((2.49999850631e-5)*r01);
IkReal x68=((0.0044499999701262)*r01);
IkReal x69=((0.0782634642169105)*r00);
IkReal x70=((0.000351745906566324)*r02);
IkReal x71=((0.198024999985063)*r01);
IkReal x72=((0.000702150946118151)*r01);
IkReal x73=((0.000795698107763699)*r00);
IkReal x74=((0.008)*px);
IkReal x75=((1.76)*px);
IkReal x76=((0.000168603784472602)*r01);
IkReal x77=((0.0021156981077637)*r00);
IkReal x78=((4.99999701262e-5)*r00);
IkReal x79=((1.9761017793599e-5)*r01);
IkReal x80=((0.396049999970126)*r00);
IkReal x81=((0.156526928433821)*r01);
IkReal x82=((0.0015913962155274)*r01);
IkReal x83=((0.0014043018922363)*r00);
IkReal x84=((-2.0e-5)+(((-1.0)*x55)));
IkReal x85=((0.00178)+(((-1.0)*x55)));
IkReal x86=((0.0021156981077637)*r02);
IkReal x87=((4.99999701262e-5)*r02);
IkReal x88=((7.90440239474886e-6)*r01);
IkReal x89=((0.396049999970126)*r02);
IkReal x90=((0.000703491813132649)*r01);
IkReal x91=((0.0014043018922363)*r02);
IkReal x92=(px*r02);
IkReal x93=(pz*r00);
IkReal x94=(px*r01);
IkReal x95=((4.0)*py);
IkReal x96=(py*r00);
IkReal x97=((1.0)*r02);
IkReal x98=(pz*r02);
IkReal x99=((1.0)*r01);
IkReal x100=((4.0)*r00);
IkReal x101=((2.0)*r01);
IkReal x102=((0.790440239474886)*r01);
IkReal x103=((2.0)*r00);
IkReal x104=(pz*r01);
IkReal x105=(px*r00);
IkReal x106=((2.0)*px);
IkReal x107=(py*r02);
IkReal x108=(py*r01);
IkReal x109=((0.395220119737443)*r00);
IkReal x110=((1.0)*x61);
IkReal x111=((1.0)*x60);
IkReal x112=((1.0)*x59);
IkReal x113=(r01*x55);
IkReal x114=((0.177849053881849)*x96);
IkReal x115=((0.002)*x93);
IkReal x116=((0.177849053881849)*x94);
IkReal x117=((0.44)*x105);
IkReal x118=(r02*x54);
IkReal x119=((0.44)*x108);
IkReal x120=(r02*x53);
IkReal x121=(r02*x52);
IkReal x122=((0.00395220119737443)*x93);
IkReal x123=((0.01)*x104);
IkReal x124=(r01*x53);
IkReal x125=((0.000790440239474886)*x108);
IkReal x126=((0.01)*x107);
IkReal x127=((0.000790440239474886)*x98);
IkReal x128=((0.00395220119737443)*x92);
IkReal x129=((0.002)*x96);
IkReal x130=((0.000790440239474886)*x105);
IkReal x131=(r01*x61);
IkReal x132=(r01*x59);
IkReal x133=(r02*x60);
IkReal x134=(r02*x61);
IkReal x135=(r00*x55);
IkReal x136=((0.004)*x92);
IkReal x137=((0.355698107763699)*x93);
IkReal x138=((0.004)*x94);
IkReal x139=((0.355698107763699)*x92);
IkReal x140=(r00*x52);
IkReal x141=((0.89)*x107);
IkReal x142=((0.351745906566324)*x93);
IkReal x143=(r01*x60);
IkReal x144=((0.351745906566324)*x92);
IkReal x145=((0.89)*x104);
IkReal x146=(r02*x59);
IkReal x147=((((-1.0)*x74))+x52);
IkReal x148=((-0.016)*px);
IkReal x149=(r02*x74);
IkReal x150=(r00*x57);
IkReal x151=((0.00790440239474886)*x104);
IkReal x152=((0.02)*x92);
IkReal x153=((0.02)*x93);
IkReal x154=((0.00790440239474886)*x107);
IkReal x155=(r01*x57);
IkReal x156=(r02*x56);
IkReal x157=((1.78)*x93);
IkReal x158=((0.703491813132649)*x104);
IkReal x159=((1.78)*x92);
IkReal x160=((0.703491813132649)*x107);
IkReal x161=((-2.0e-5)+x55);
IkReal x162=((-0.008)*py);
IkReal x163=((0.00178)+x55);
IkReal x164=((0.00790440239474886)*x96);
IkReal x165=((0.00790440239474886)*x94);
IkReal x166=((0.703491813132649)*x96);
IkReal x167=((0.703491813132649)*x94);
IkReal x168=((0.0022250000149369)+x54);
IkReal x169=(x106*x93);
IkReal x170=(py*pz*x101);
IkReal x171=(x106*x96);
IkReal x172=((0.790440239474886)*py*x94);
IkReal x173=((0.790440239474886)*pz*x92);
IkReal x174=(x109*x61);
IkReal x175=((2.0)*py*x98);
IkReal x176=(x109*x59);
IkReal x177=(x109*x60);
IkReal x178=(x60*x99);
IkReal x179=(x59*x97);
IkReal x180=((2.0)*x133);
IkReal x181=((2.0)*x134);
IkReal x182=(x104*x95);
IkReal x183=((2.0)*x146);
IkReal x184=((4.0)*px*x93);
IkReal x185=(x95*x98);
IkReal x186=(x101*x60);
IkReal x187=(x105*x95);
IkReal x188=(x101*x59);
IkReal x189=(x101*x61);
IkReal x190=(x59*x99);
IkReal x191=(x61*x99);
IkReal x192=(x60*x97);
IkReal x193=(x61*x97);
IkReal x194=(x74+x52);
IkReal x195=((1.58088047894977)*py*x98);
IkReal x196=(x103*x59);
IkReal x197=(x102*x60);
IkReal x198=(x103*x60);
IkReal x199=((1.58088047894977)*px*x96);
IkReal x200=(x103*x61);
IkReal x201=(x102*x61);
IkReal x202=(x102*x59);
IkReal x203=((4.0)*pz*x92);
IkReal x204=(x94*x95);
IkReal x205=(x58+x57);
IkReal x206=(x53+x52);
IkReal x207=(x63+x64);
IkReal x208=(x166+x89);
IkReal x209=(x150+x82);
IkReal x210=(x113+x83);
IkReal x211=(x126+x66);
IkReal x212=(x114+x62);
IkReal x213=(x144+x71);
IkReal x214=(x164+x87);
IkReal x215=(x121+x73);
IkReal x216=(x135+x90);
IkReal x217=(x135+x88);
IkReal x218=(x157+x81);
IkReal x219=(x153+x79);
IkReal x220=(x124+x65);
IkReal x221=(x138+x86);
IkReal x222=(x142+x143);
IkReal x223=(x120+x113);
IkReal x224=(x131+x132);
IkReal x225=(x145+x129);
IkReal x226=(x113+x115);
IkReal x227=(x134+x133);
IkReal x228=(x149+x121);
IkReal x229=(x143+x122);
IkReal x230=(x178+x122);
IkReal x231=(x178+x142);
IkReal x232=(x171+x175);
IkReal x233=(x128+x129+x67);
IkReal x234=(x191+x190);
IkReal x235=(x193+x192);
IkReal x236=(x180+x181);
IkReal x237=(x202+x201);
IkReal x238=(x177+x176);
IkReal x239=(x145+x124+x70);
IkReal x240=(x121+x115+x63);
IkReal x241=(x141+x129+x69);
IkReal x242=(x117+x119+x118);
IkReal x243=(x112+x111+x110);
IkReal x244=(x130+x127+x125);
IkReal x245=(x141+x124+x70+x69);
IkReal x246=(x128+x220+x67);
IkReal x247=(x136+x236);
IkReal x248=(x243+x54);
IkReal x249=(x173+x172+x174);
IkReal x250=(x123+x244);
IkReal x251=(x184+x182+x183);
IkReal x252=(x204+x203+x200);
IkReal x253=(x199+x197+x195);
IkReal x254=((((0.711396215527398)*x104))+(((0.0088999999402524)*r00))+((x100*x60))+((x100*x59)));
IkReal x255=(x139+x188+x189+x68);
IkReal x256=(x151+x198+x196+x78);
IkReal x257=(x158+x198+x196+x80);
IkReal x258=(x170+x169+x146+x116);
IkReal x259=((((0.711396215527398)*x107))+(((8.0)*pz*x92))+((x100*x61))+(((8.0)*py*x94)));
IkReal x260=(x179+x170+x169+x116);
IkReal x261=(x137+x185+x186+x187);
IkReal x262=(x238+x244);
IkReal x263=(x120+x260);
IkReal x264=(x140+x261);
op[0]=(x168+x53+(((-1.0)*x243))+(((-1.0)*x52)));
op[1]=x84;
op[2]=((-1.0)*x205);
op[3]=x56;
op[4]=((0.0022250000149369)+x206+(((-1.0)*x248)));
op[5]=x161;
op[6]=x85;
op[7]=(x168+x206+(((-1.0)*x243)));
op[8]=x56;
op[9]=(x57+(((-1.0)*x58)));
op[10]=x163;
op[11]=((0.0022250000149369)+x53+(((-1.0)*x248))+(((-1.0)*x52)));
op[12]=((((-1.0)*x235))+x258+x223+x64+(((-1.0)*x240))+(((-1.0)*x242))+(((-1.0)*x212)));
op[13]=(x123+(((-1.0)*x230))+(((-1.0)*x232))+x224+x233+x249+(((-1.0)*x211))+(((-1.0)*x262))+(((-1.0)*x220)));
op[14]=(x140+x255+(((-1.0)*x261))+(((-1.0)*x221)));
op[15]=((((-1.0)*x165))+(((-1.0)*x136))+x214+x217+x236+(((-1.0)*x251)));
op[16]=((((-1.0)*x121))+x212+x227+x226+x207+(((-1.0)*x242))+(((-1.0)*x263)));
op[17]=(x123+(((-1.0)*x233))+(((-1.0)*x234))+x229+x220+x232+x249+(((-1.0)*x211))+(((-1.0)*x262)));
op[18]=((((-1.0)*x239))+(((-1.0)*x232))+(((-1.0)*x231))+x213+x224+x262+x241+(((-1.0)*x249)));
op[19]=((((-1.0)*x72))+x212+x227+x226+x242+(((-1.0)*x215))+(((-1.0)*x263)));
op[20]=((((-1.0)*x167))+(((-1.0)*x136))+x216+x236+x208+(((-1.0)*x251)));
op[21]=((((-1.0)*x140))+x138+x261+(((-1.0)*x91))+(((-1.0)*x255)));
op[22]=((((-1.0)*x234))+x222+x232+x262+x245+(((-1.0)*x249))+(((-1.0)*x213))+(((-1.0)*x225)));
op[23]=((((-1.0)*x115))+(((-1.0)*x235))+x258+x223+x242+x72+(((-1.0)*x212))+(((-1.0)*x215)));
op[24]=x194;
op[25]=0;
op[26]=x75;
op[27]=x148;
op[28]=x147;
op[29]=0;
op[30]=0;
op[31]=x147;
op[32]=x148;
op[33]=x75;
op[34]=0;
op[35]=x194;
op[36]=((((-1.0)*x150))+(((-1.0)*x113))+x228+x77+x76);
op[37]=(x154+x152+(((-1.0)*x237))+x252+x253+(((-1.0)*x219))+(((-1.0)*x256)));
op[38]=(x259+(((-1.0)*x254)));
op[39]=((((-1.0)*x156))+x155+(((-1.58088047894977e-5)*r00)));
op[40]=((((-1.0)*x150))+(((-1.0)*x77))+(((-1.0)*x121))+x149+x113+x76);
op[41]=((((-1.0)*x154))+x152+(((-1.0)*x237))+x256+x253+(((-1.0)*x219))+(((-1.0)*x252)));
op[42]=((((-1.0)*x159))+x160+x218+x252+x237+(((-1.0)*x257))+(((-1.0)*x253)));
op[43]=((((-1.0)*x121))+x149+(((-1.0)*x209))+x210);
op[44]=((((-1.0)*x156))+(((-0.0014069836262653)*r00))+x155);
op[45]=(x254+(((-1.0)*x259)));
op[46]=((((-1.0)*x159))+(((-1.0)*x160))+x218+x257+x237+(((-1.0)*x253))+(((-1.0)*x252)));
op[47]=((((-1.0)*x209))+x228+(((-1.0)*x210)));
op[48]=(x168+x52+(((-1.0)*x243))+(((-1.0)*x53)));
op[49]=x84;
op[50]=(x58+(((-1.0)*x57)));
op[51]=x162;
op[52]=((0.0022250000149369)+(((-1.0)*x206))+(((-1.0)*x248)));
op[53]=x161;
op[54]=x85;
op[55]=(x168+(((-1.0)*x206))+(((-1.0)*x243)));
op[56]=x162;
op[57]=x205;
op[58]=x163;
op[59]=((0.0022250000149369)+x52+(((-1.0)*x248))+(((-1.0)*x53)));
op[60]=((((-1.0)*x235))+x258+x240+(((-1.0)*x242))+(((-1.0)*x64))+(((-1.0)*x212))+(((-1.0)*x223)));
op[61]=(x129+(((-1.0)*x234))+x211+x229+x238+x232+(((-1.0)*x249))+(((-1.0)*x246))+(((-1.0)*x250)));
op[62]=(x264+(((-1.0)*x221))+(((-1.0)*x255)));
op[63]=((((-1.0)*x165))+x214+x247+(((-1.0)*x217))+(((-1.0)*x251)));
op[64]=(x120+x121+(((-1.0)*x207))+x212+x227+(((-1.0)*x242))+(((-1.0)*x260))+(((-1.0)*x226)));
op[65]=((((-1.0)*x129))+(((-1.0)*x230))+(((-1.0)*x232))+x211+x224+x238+x246+(((-1.0)*x249))+(((-1.0)*x250)));
op[66]=((((-1.0)*x238))+(((-1.0)*x234))+x222+x225+x232+x244+x249+(((-1.0)*x245))+(((-1.0)*x213)));
op[67]=(x120+x212+x215+x227+x242+x72+(((-1.0)*x260))+(((-1.0)*x226)));
op[68]=((((-1.0)*x167))+x208+x247+(((-1.0)*x216))+(((-1.0)*x251)));
op[69]=(x138+x255+(((-1.0)*x91))+(((-1.0)*x264)));
op[70]=((((-1.0)*x238))+(((-1.0)*x232))+(((-1.0)*x231))+x213+x224+x239+x244+x249+(((-1.0)*x241)));
op[71]=((((-1.0)*x72))+x115+(((-1.0)*x235))+x215+x258+x242+(((-1.0)*x212))+(((-1.0)*x223)));
solvedialyticpoly8qep(op,zeror,numroots);
IkReal j0array[16], cj0array[16], sj0array[16], j1array[16], cj1array[16], sj1array[16], j2array[16], cj2array[16], sj2array[16];
int numsolutions = 0;
for(int ij0 = 0; ij0 < numroots; ij0 += 3)
{
IkReal htj0 = zeror[ij0+0], htj1 = zeror[ij0+1], htj2 = zeror[ij0+2];
if(isnan(htj0)||isnan(htj1)||isnan(htj2)){
continue;
}
j0array[numsolutions]=((2.0)*(atan(htj0)));
j1array[numsolutions]=((2.0)*(atan(htj1)));
j2array[numsolutions]=((2.0)*(atan(htj2)));
if(isinf(htj0)){
cj0array[numsolutions] = IKcos(j0array[numsolutions]);
sj0array[numsolutions] = IKsin(j0array[numsolutions]);
}
else{
IkReal x265=htj0*htj0;
CheckValue<IkReal> x266=IKPowWithIntegerCheck(((1.0)+x265),-1);
if(!x266.valid){
continue;
}
cj0array[numsolutions]=((x266.value)*(((1.0)+(((-1.0)*x265)))));
CheckValue<IkReal> x267=IKPowWithIntegerCheck(((1.0)+(htj0*htj0)),-1);
if(!x267.valid){
continue;
}
sj0array[numsolutions]=((2.0)*htj0*(x267.value));
}
if(isinf(htj1)){
cj1array[numsolutions] = IKcos(j1array[numsolutions]);
sj1array[numsolutions] = IKsin(j1array[numsolutions]);
}
else{
IkReal x268=htj1*htj1;
CheckValue<IkReal> x269=IKPowWithIntegerCheck(((1.0)+x268),-1);
if(!x269.valid){
continue;
}
cj1array[numsolutions]=((x269.value)*(((1.0)+(((-1.0)*x268)))));
CheckValue<IkReal> x270=IKPowWithIntegerCheck(((1.0)+(htj1*htj1)),-1);
if(!x270.valid){
continue;
}
sj1array[numsolutions]=((2.0)*htj1*(x270.value));
}
if(isinf(htj2)){
cj2array[numsolutions] = IKcos(j2array[numsolutions]);
sj2array[numsolutions] = IKsin(j2array[numsolutions]);
}
else{
IkReal x271=htj2*htj2;
CheckValue<IkReal> x272=IKPowWithIntegerCheck(((1.0)+x271),-1);
if(!x272.valid){
continue;
}
cj2array[numsolutions]=((x272.value)*(((1.0)+(((-1.0)*x271)))));
CheckValue<IkReal> x273=IKPowWithIntegerCheck(((1.0)+(htj2*htj2)),-1);
if(!x273.valid){
continue;
}
sj2array[numsolutions]=((2.0)*htj2*(x273.value));
}
if( j0array[numsolutions] > IKPI )
{
    j0array[numsolutions]-=IK2PI;
}
else if( j0array[numsolutions] < -IKPI )
{
    j0array[numsolutions]+=IK2PI;
}
if( j1array[numsolutions] > IKPI )
{
    j1array[numsolutions]-=IK2PI;
}
else if( j1array[numsolutions] < -IKPI )
{
    j1array[numsolutions]+=IK2PI;
}
if( j2array[numsolutions] > IKPI )
{
    j2array[numsolutions]-=IK2PI;
}
else if( j2array[numsolutions] < -IKPI )
{
    j2array[numsolutions]+=IK2PI;
}
numsolutions++;
}
bool j0valid[16]={true,true,true,true,true,true,true,true,true,true,true,true,true,true,true,true};
_nj0 = 16;
_nj1 = 1;
_nj2 = 1;
for(int ij0 = 0; ij0 < numsolutions; ++ij0)
    {
if( !j0valid[ij0] )
{
    continue;
}
_ij0[0] = ij0; _ij0[1] = -1;
_ij1[0] = 0; _ij1[1] = -1;
_ij2[0] = 0; _ij2[1] = -1;
for(int iij0 = ij0+1; iij0 < numsolutions; ++iij0)
{
if( !j0valid[iij0] ) { continue; }
if( IKabs(cj0array[ij0]-cj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj0array[ij0]-sj0array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(cj1array[ij0]-cj1array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj1array[ij0]-sj1array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(cj2array[ij0]-cj2array[iij0]) < IKFAST_SOLUTION_THRESH && IKabs(sj2array[ij0]-sj2array[iij0]) < IKFAST_SOLUTION_THRESH &&  1 )
{
    j0valid[iij0]=false; _ij0[1] = iij0; _ij1[1] = 0; _ij2[1] = 0;  break; 
}
}
    j0 = j0array[ij0]; cj0 = cj0array[ij0]; sj0 = sj0array[ij0];

    j1 = j1array[ij0]; cj1 = cj1array[ij0]; sj1 = sj1array[ij0];

    j2 = j2array[ij0]; cj2 = cj2array[ij0]; sj2 = sj2array[ij0];

innerfn(solutions);
    }
}
return solutions.GetNumSolutions()>0;
}
inline void innerfn(IkSolutionListBase<IkReal>& solutions) {
for(int fniter = 0; fniter < 1; ++fniter) {
{
IkReal j3eval[2];
j3eval[0]=cj2;
j3eval[1]=IKsign(cj2);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal j3eval[2];
j3eval[0]=sj2;
j3eval[1]=IKsign(sj2);
if( IKabs(j3eval[0]) < 0.0000010000000000  || IKabs(j3eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x274=(pz*sj1);
IkReal x275=((164.375508947892)*cj0);
IkReal x276=(cj1*py);
IkReal x277=((415.908757522496)*px);
IkReal x278=(cj1*sj0);
IkReal x279=(py*sj0);
if( IKabs(((-0.6674420060971)+(((-164.375508947892)*x279))+(((-415.908757522496)*cj0*x276))+((x277*x278))+(((-1.0)*px*x275))+(((-415.908757522496)*x274)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.74465977541828)+((x275*x276))+(((164.375508947892)*x274))+(((-1.0)*cj0*x277))+(((-415.908757522496)*x279))+(((-164.375508947892)*px*x278)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.6674420060971)+(((-164.375508947892)*x279))+(((-415.908757522496)*cj0*x276))+((x277*x278))+(((-1.0)*px*x275))+(((-415.908757522496)*x274))))+IKsqr(((0.74465977541828)+((x275*x276))+(((164.375508947892)*x274))+(((-1.0)*cj0*x277))+(((-415.908757522496)*x279))+(((-164.375508947892)*px*x278))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-0.6674420060971)+(((-164.375508947892)*x279))+(((-415.908757522496)*cj0*x276))+((x277*x278))+(((-1.0)*px*x275))+(((-415.908757522496)*x274))), ((0.74465977541828)+((x275*x276))+(((164.375508947892)*x274))+(((-1.0)*cj0*x277))+(((-415.908757522496)*x279))+(((-164.375508947892)*px*x278))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x280=IKsin(j3);
IkReal x281=IKcos(j3);
evalcond[0]=((-0.001)+((cj0*px))+((py*sj0))+(((0.00082188)*x280))+(((0.00207955)*x281)));
evalcond[1]=((0.002)+(((-1.0)*cj1*px*sj0))+(((-0.00082188)*x281))+((cj0*cj1*py))+((pz*sj1))+(((0.00207955)*x280)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj2=0;
cj2=1.0;
j2=0;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=0;
cj2=1.0;
j2=0;
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs((((r01*sj0))+((cj0*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj0))+((cj0*r00))))+IKsqr((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r01*sj0))+((cj0*r00))), (((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(((-1.0)*(IKsin(j4))))+((cj0*r00)));
evalcond[1]=((((-1.0)*r00*sj0*sj1))+(IKcos(j4))+((cj0*r01*sj1))+(((-1.0)*cj1*r02)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x282=((1.0)*cj0);
if( IKabs(((((-1.0)*r01*sj0))+(((-1.0)*r00*x282)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*r01*sj1*x282)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj0))+(((-1.0)*r00*x282))))+IKsqr((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*r01*sj1*x282))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*r01*sj0))+(((-1.0)*r00*x282))), (((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*r01*sj1*x282))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(IKsin(j4))+((cj0*r00)));
evalcond[1]=((((-1.0)*r00*sj0*sj1))+(IKcos(j4))+((cj0*r01*sj1))+(((-1.0)*cj1*r02)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x283=(r00*sj0);
IkReal x284=((1.0)*cj0*r01);
if( IKabs(((((-1.0)*r02*sj1))+(((-1.0)*cj1*x284))+((cj1*x283)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj1*x284))+((cj1*r02))+((sj1*x283)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r02*sj1))+(((-1.0)*cj1*x284))+((cj1*x283))))+IKsqr(((((-1.0)*sj1*x284))+((cj1*r02))+((sj1*x283))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*r02*sj1))+(((-1.0)*cj1*x284))+((cj1*x283))), ((((-1.0)*sj1*x284))+((cj1*r02))+((sj1*x283))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x285=((1.0)*cj1);
IkReal x286=(cj0*r01);
IkReal x287=(r00*sj0);
evalcond[0]=((IKsin(j4))+((r02*sj1))+(((-1.0)*x285*x287))+((cj1*x286)));
evalcond[1]=((((-1.0)*r02*x285))+(IKcos(j4))+(((-1.0)*sj1*x287))+((sj1*x286)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x288=(r00*sj0);
IkReal x289=(cj0*r01);
if( IKabs((((r02*sj1))+((cj1*x289))+(((-1.0)*cj1*x288)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*r02))+(((-1.0)*sj1*x289))+((sj1*x288)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r02*sj1))+((cj1*x289))+(((-1.0)*cj1*x288))))+IKsqr((((cj1*r02))+(((-1.0)*sj1*x289))+((sj1*x288))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r02*sj1))+((cj1*x289))+(((-1.0)*cj1*x288))), (((cj1*r02))+(((-1.0)*sj1*x289))+((sj1*x288))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x290=((1.0)*cj1);
IkReal x291=(cj0*r01);
IkReal x292=(r00*sj0);
evalcond[0]=((((-1.0)*sj1*x292))+((sj1*x291))+(((-1.0)*r02*x290))+(IKcos(j4)));
evalcond[1]=((((-1.0)*x290*x292))+(((-1.0)*(IKsin(j4))))+((cj1*x291))+((r02*sj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x293=(r00*sj0);
IkReal x294=((1.0)*cj0*r01);
CheckValue<IkReal> x295=IKPowWithIntegerCheck(cj3,-1);
if(!x295.valid){
continue;
}
if( IKabs(((x295.value)*(((((-1.0)*cj1*x294))+((cj1*x293))+(((-1.0)*r02*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((sj1*x293))+((cj1*r02))+(((-1.0)*sj1*x294)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x295.value)*(((((-1.0)*cj1*x294))+((cj1*x293))+(((-1.0)*r02*sj1))))))+IKsqr((((sj1*x293))+((cj1*r02))+(((-1.0)*sj1*x294))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x295.value)*(((((-1.0)*cj1*x294))+((cj1*x293))+(((-1.0)*r02*sj1))))), (((sj1*x293))+((cj1*r02))+(((-1.0)*sj1*x294))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x296=IKsin(j4);
IkReal x297=((1.0)*cj1);
IkReal x298=(cj0*r01);
IkReal x299=(r00*sj0);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x296))+((cj0*r00)));
evalcond[1]=((((-1.0)*sj1*x299))+((sj1*x298))+(((-1.0)*r02*x297))+(IKcos(j4)));
evalcond[2]=(((cj3*x296))+((cj1*x298))+(((-1.0)*x297*x299))+((r02*sj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x300=IKPowWithIntegerCheck(sj3,-1);
if(!x300.valid){
continue;
}
if( IKabs(((x300.value)*((((r01*sj0))+((cj0*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x300.value)*((((r01*sj0))+((cj0*r00))))))+IKsqr((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x300.value)*((((r01*sj0))+((cj0*r00))))), (((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x301=IKsin(j4);
IkReal x302=((1.0)*cj1);
IkReal x303=(cj0*r01);
IkReal x304=(r00*sj0);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x301))+((cj0*r00)));
evalcond[1]=((((-1.0)*sj1*x304))+(((-1.0)*r02*x302))+(IKcos(j4))+((sj1*x303)));
evalcond[2]=(((cj1*x303))+(((-1.0)*x302*x304))+((r02*sj1))+((cj3*x301)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x305=(pz*sj1);
IkReal x306=((164.375508947892)*cj0);
IkReal x307=(cj1*py);
IkReal x308=((415.908757522496)*px);
IkReal x309=(cj1*sj0);
IkReal x310=(py*sj0);
if( IKabs(((-0.6674420060971)+(((-1.0)*px*x306))+(((-1.0)*x308*x309))+(((415.908757522496)*x305))+(((-164.375508947892)*x310))+(((415.908757522496)*cj0*x307)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((0.74465977541828)+(((-1.0)*cj0*x308))+(((164.375508947892)*px*x309))+(((-1.0)*x306*x307))+(((-415.908757522496)*x310))+(((-164.375508947892)*x305)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-0.6674420060971)+(((-1.0)*px*x306))+(((-1.0)*x308*x309))+(((415.908757522496)*x305))+(((-164.375508947892)*x310))+(((415.908757522496)*cj0*x307))))+IKsqr(((0.74465977541828)+(((-1.0)*cj0*x308))+(((164.375508947892)*px*x309))+(((-1.0)*x306*x307))+(((-415.908757522496)*x310))+(((-164.375508947892)*x305))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-0.6674420060971)+(((-1.0)*px*x306))+(((-1.0)*x308*x309))+(((415.908757522496)*x305))+(((-164.375508947892)*x310))+(((415.908757522496)*cj0*x307))), ((0.74465977541828)+(((-1.0)*cj0*x308))+(((164.375508947892)*px*x309))+(((-1.0)*x306*x307))+(((-415.908757522496)*x310))+(((-164.375508947892)*x305))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x311=IKcos(j3);
IkReal x312=IKsin(j3);
evalcond[0]=((-0.001)+(((0.00207955)*x311))+(((0.00082188)*x312))+((cj0*px))+((py*sj0)));
evalcond[1]=((-0.002)+(((-1.0)*cj1*px*sj0))+((cj0*cj1*py))+(((0.00082188)*x311))+((pz*sj1))+(((-0.00207955)*x312)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs((((r01*sj0))+((cj0*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj0))+((cj0*r00))))+IKsqr(((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r01*sj0))+((cj0*r00))), ((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(((-1.0)*(IKsin(j4))))+((cj0*r00)));
evalcond[1]=((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*(IKcos(j4))))+(((-1.0)*cj1*r02)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x313=((1.0)*r00);
if( IKabs(((((-1.0)*cj0*x313))+(((-1.0)*r01*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj0*r01*sj1))+(((-1.0)*cj1*r02))+(((-1.0)*sj0*sj1*x313)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj0*x313))+(((-1.0)*r01*sj0))))+IKsqr((((cj0*r01*sj1))+(((-1.0)*cj1*r02))+(((-1.0)*sj0*sj1*x313))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*cj0*x313))+(((-1.0)*r01*sj0))), (((cj0*r01*sj1))+(((-1.0)*cj1*r02))+(((-1.0)*sj0*sj1*x313))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(IKsin(j4))+((cj0*r00)));
evalcond[1]=((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*(IKcos(j4))))+(((-1.0)*cj1*r02)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x314=((1.0)*cj1);
IkReal x315=(cj0*r01);
IkReal x316=(r00*sj0);
if( IKabs((((cj1*x315))+((r02*sj1))+(((-1.0)*x314*x316)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r02*x314))+(((-1.0)*sj1*x316))+((sj1*x315)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*x315))+((r02*sj1))+(((-1.0)*x314*x316))))+IKsqr(((((-1.0)*r02*x314))+(((-1.0)*sj1*x316))+((sj1*x315))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((cj1*x315))+((r02*sj1))+(((-1.0)*x314*x316))), ((((-1.0)*r02*x314))+(((-1.0)*sj1*x316))+((sj1*x315))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x317=((1.0)*cj1);
IkReal x318=(cj0*r01);
IkReal x319=(r00*sj0);
evalcond[0]=((((-1.0)*(IKsin(j4))))+((cj1*x318))+((r02*sj1))+(((-1.0)*x317*x319)));
evalcond[1]=((((-1.0)*r02*x317))+(((-1.0)*sj1*x319))+((sj1*x318))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x320=((1.0)*cj1);
IkReal x321=(cj0*r01);
IkReal x322=((1.0)*sj1);
IkReal x323=(r00*sj0);
if( IKabs((((cj1*x323))+(((-1.0)*x320*x321))+(((-1.0)*r02*x322)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x322*x323))+((sj1*x321))+(((-1.0)*r02*x320)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*x323))+(((-1.0)*x320*x321))+(((-1.0)*r02*x322))))+IKsqr(((((-1.0)*x322*x323))+((sj1*x321))+(((-1.0)*r02*x320))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((cj1*x323))+(((-1.0)*x320*x321))+(((-1.0)*r02*x322))), ((((-1.0)*x322*x323))+((sj1*x321))+(((-1.0)*r02*x320))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x324=((1.0)*cj1);
IkReal x325=(cj0*r01);
IkReal x326=(r00*sj0);
evalcond[0]=(((cj1*x325))+(IKsin(j4))+((r02*sj1))+(((-1.0)*x324*x326)));
evalcond[1]=((((-1.0)*sj1*x326))+((sj1*x325))+(((-1.0)*r02*x324))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x327=((1.0)*cj1);
IkReal x328=(cj0*r01);
IkReal x329=(r00*sj0);
CheckValue<IkReal> x330=IKPowWithIntegerCheck(cj3,-1);
if(!x330.valid){
continue;
}
if( IKabs(((x330.value)*((((cj1*x328))+(((-1.0)*x327*x329))+((r02*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj1*x329))+((sj1*x328))+(((-1.0)*r02*x327)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x330.value)*((((cj1*x328))+(((-1.0)*x327*x329))+((r02*sj1))))))+IKsqr(((((-1.0)*sj1*x329))+((sj1*x328))+(((-1.0)*r02*x327))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x330.value)*((((cj1*x328))+(((-1.0)*x327*x329))+((r02*sj1))))), ((((-1.0)*sj1*x329))+((sj1*x328))+(((-1.0)*r02*x327))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x331=IKsin(j4);
IkReal x332=((1.0)*cj1);
IkReal x333=(cj0*r01);
IkReal x334=(r00*sj0);
IkReal x335=((1.0)*x331);
evalcond[0]=((((-1.0)*sj3*x335))+((r01*sj0))+((cj0*r00)));
evalcond[1]=(((cj1*x333))+((r02*sj1))+(((-1.0)*x332*x334))+(((-1.0)*cj3*x335)));
evalcond[2]=((((-1.0)*sj1*x334))+(((-1.0)*r02*x332))+(((-1.0)*(IKcos(j4))))+((sj1*x333)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x336=IKPowWithIntegerCheck(sj3,-1);
if(!x336.valid){
continue;
}
if( IKabs(((x336.value)*((((r01*sj0))+((cj0*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x336.value)*((((r01*sj0))+((cj0*r00))))))+IKsqr(((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x336.value)*((((r01*sj0))+((cj0*r00))))), ((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x337=IKsin(j4);
IkReal x338=((1.0)*cj1);
IkReal x339=(cj0*r01);
IkReal x340=(r00*sj0);
IkReal x341=((1.0)*x337);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x341))+((cj0*r00)));
evalcond[1]=((((-1.0)*cj3*x341))+((cj1*x339))+((r02*sj1))+(((-1.0)*x338*x340)));
evalcond[2]=((((-1.0)*sj1*x340))+(((-1.0)*r02*x338))+(((-1.0)*(IKcos(j4))))+((sj1*x339)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x342=((164.375508947892)*px);
IkReal x343=(sj0*sj1);
IkReal x344=(cj1*pz);
IkReal x345=((415.908757522496)*px);
IkReal x346=(py*sj0);
IkReal x347=(cj0*py*sj1);
if( IKabs(((90.832484648852)+(((415.908757522496)*x347))+(((-164.375508947892)*x346))+(((-1.0)*x343*x345))+(((-1.0)*cj0*x342))+(((-415.908757522496)*x344)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((-35.417952193118)+(((164.375508947892)*x344))+(((-164.375508947892)*x347))+(((-1.0)*cj0*x345))+((x342*x343))+(((-415.908757522496)*x346)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((90.832484648852)+(((415.908757522496)*x347))+(((-164.375508947892)*x346))+(((-1.0)*x343*x345))+(((-1.0)*cj0*x342))+(((-415.908757522496)*x344))))+IKsqr(((-35.417952193118)+(((164.375508947892)*x344))+(((-164.375508947892)*x347))+(((-1.0)*cj0*x345))+((x342*x343))+(((-415.908757522496)*x346))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((90.832484648852)+(((415.908757522496)*x347))+(((-164.375508947892)*x346))+(((-1.0)*x343*x345))+(((-1.0)*cj0*x342))+(((-415.908757522496)*x344))), ((-35.417952193118)+(((164.375508947892)*x344))+(((-164.375508947892)*x347))+(((-1.0)*cj0*x345))+((x342*x343))+(((-415.908757522496)*x346))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x348=IKcos(j3);
IkReal x349=IKsin(j3);
evalcond[0]=((-0.001)+(((0.00207955)*x348))+(((0.00082188)*x349))+((cj0*px))+((py*sj0)));
evalcond[1]=((0.218)+((cj0*py*sj1))+(((0.00082188)*x348))+(((-0.00207955)*x349))+(((-1.0)*cj1*pz))+(((-1.0)*px*sj0*sj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs((((r01*sj0))+((cj0*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj0))+((cj0*r00))))+IKsqr(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r01*sj0))+((cj0*r00))), ((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(((-1.0)*(IKsin(j4))))+((cj0*r00)));
evalcond[1]=(((cj0*cj1*r01))+((r02*sj1))+(IKcos(j4))+(((-1.0)*cj1*r00*sj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x350=((1.0)*cj0);
if( IKabs(((((-1.0)*r01*sj0))+(((-1.0)*r00*x350)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj1*r01*x350))+(((-1.0)*r02*sj1))+((cj1*r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj0))+(((-1.0)*r00*x350))))+IKsqr(((((-1.0)*cj1*r01*x350))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*r01*sj0))+(((-1.0)*r00*x350))), ((((-1.0)*cj1*r01*x350))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(IKsin(j4))+((cj0*r00)));
evalcond[1]=(((cj0*cj1*r01))+((r02*sj1))+(IKcos(j4))+(((-1.0)*cj1*r00*sj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x351=((1.0)*cj1);
IkReal x352=(cj0*r01);
IkReal x353=((1.0)*sj1);
IkReal x354=(r00*sj0);
if( IKabs((((sj1*x352))+(((-1.0)*x353*x354))+(((-1.0)*r02*x351)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*x354))+(((-1.0)*r02*x353))+(((-1.0)*x351*x352)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj1*x352))+(((-1.0)*x353*x354))+(((-1.0)*r02*x351))))+IKsqr((((cj1*x354))+(((-1.0)*r02*x353))+(((-1.0)*x351*x352))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((sj1*x352))+(((-1.0)*x353*x354))+(((-1.0)*r02*x351))), (((cj1*x354))+(((-1.0)*r02*x353))+(((-1.0)*x351*x352))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x355=((1.0)*cj1);
IkReal x356=(cj0*r01);
IkReal x357=(r00*sj0);
evalcond[0]=(((cj1*x356))+((r02*sj1))+(IKcos(j4))+(((-1.0)*x355*x357)));
evalcond[1]=((((-1.0)*(IKsin(j4))))+((sj1*x356))+(((-1.0)*r02*x355))+(((-1.0)*sj1*x357)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x358=(r00*sj0);
IkReal x359=((1.0)*cj0*r01);
if( IKabs((((cj1*r02))+((sj1*x358))+(((-1.0)*sj1*x359)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*x358))+(((-1.0)*cj1*x359))+(((-1.0)*r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r02))+((sj1*x358))+(((-1.0)*sj1*x359))))+IKsqr((((cj1*x358))+(((-1.0)*cj1*x359))+(((-1.0)*r02*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((cj1*r02))+((sj1*x358))+(((-1.0)*sj1*x359))), (((cj1*x358))+(((-1.0)*cj1*x359))+(((-1.0)*r02*sj1))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x360=((1.0)*cj1);
IkReal x361=(cj0*r01);
IkReal x362=(r00*sj0);
evalcond[0]=((((-1.0)*x360*x362))+((r02*sj1))+(IKcos(j4))+((cj1*x361)));
evalcond[1]=((((-1.0)*r02*x360))+((sj1*x361))+(IKsin(j4))+(((-1.0)*sj1*x362)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x363=((1.0)*cj1);
IkReal x364=(cj0*r01);
IkReal x365=((1.0)*sj1);
IkReal x366=(r00*sj0);
CheckValue<IkReal> x367=IKPowWithIntegerCheck(cj3,-1);
if(!x367.valid){
continue;
}
if( IKabs(((x367.value)*(((((-1.0)*r02*x363))+((sj1*x364))+(((-1.0)*x365*x366)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x363*x364))+(((-1.0)*r02*x365))+((cj1*x366)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x367.value)*(((((-1.0)*r02*x363))+((sj1*x364))+(((-1.0)*x365*x366))))))+IKsqr(((((-1.0)*x363*x364))+(((-1.0)*r02*x365))+((cj1*x366))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x367.value)*(((((-1.0)*r02*x363))+((sj1*x364))+(((-1.0)*x365*x366))))), ((((-1.0)*x363*x364))+(((-1.0)*r02*x365))+((cj1*x366))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x368=IKsin(j4);
IkReal x369=((1.0)*cj1);
IkReal x370=(cj0*r01);
IkReal x371=(r00*sj0);
IkReal x372=((1.0)*x368);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x372))+((cj0*r00)));
evalcond[1]=(((r02*sj1))+(IKcos(j4))+((cj1*x370))+(((-1.0)*x369*x371)));
evalcond[2]=((((-1.0)*r02*x369))+((sj1*x370))+(((-1.0)*sj1*x371))+(((-1.0)*cj3*x372)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x373=IKPowWithIntegerCheck(sj3,-1);
if(!x373.valid){
continue;
}
if( IKabs(((x373.value)*((((r01*sj0))+((cj0*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x373.value)*((((r01*sj0))+((cj0*r00))))))+IKsqr(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x373.value)*((((r01*sj0))+((cj0*r00))))), ((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x374=IKsin(j4);
IkReal x375=((1.0)*cj1);
IkReal x376=(cj0*r01);
IkReal x377=(r00*sj0);
IkReal x378=((1.0)*x374);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x378))+((cj0*r00)));
evalcond[1]=(((r02*sj1))+(IKcos(j4))+((cj1*x376))+(((-1.0)*x375*x377)));
evalcond[2]=(((sj1*x376))+(((-1.0)*r02*x375))+(((-1.0)*sj1*x377))+(((-1.0)*cj3*x378)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x379=((164.375508947892)*px);
IkReal x380=(sj0*sj1);
IkReal x381=(cj1*pz);
IkReal x382=((415.908757522496)*py);
IkReal x383=(cj0*sj1);
IkReal x384=((415.908757522496)*px);
IkReal x385=((164.375508947892)*py);
if( IKabs(((-92.1673686610462)+(((-1.0)*sj0*x385))+((x380*x384))+(((415.908757522496)*x381))+(((-1.0)*x382*x383))+(((-1.0)*cj0*x379)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((36.9072717439545)+(((-1.0)*x379*x380))+((x383*x385))+(((-1.0)*cj0*x384))+(((-164.375508947892)*x381))+(((-1.0)*sj0*x382)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((-92.1673686610462)+(((-1.0)*sj0*x385))+((x380*x384))+(((415.908757522496)*x381))+(((-1.0)*x382*x383))+(((-1.0)*cj0*x379))))+IKsqr(((36.9072717439545)+(((-1.0)*x379*x380))+((x383*x385))+(((-1.0)*cj0*x384))+(((-164.375508947892)*x381))+(((-1.0)*sj0*x382))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j3array[0]=IKatan2(((-92.1673686610462)+(((-1.0)*sj0*x385))+((x380*x384))+(((415.908757522496)*x381))+(((-1.0)*x382*x383))+(((-1.0)*cj0*x379))), ((36.9072717439545)+(((-1.0)*x379*x380))+((x383*x385))+(((-1.0)*cj0*x384))+(((-164.375508947892)*x381))+(((-1.0)*sj0*x382))));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[2];
IkReal x386=IKsin(j3);
IkReal x387=IKcos(j3);
evalcond[0]=((-0.001)+(((0.00207955)*x387))+(((0.00082188)*x386))+((cj0*px))+((py*sj0)));
evalcond[1]=((0.222)+(((0.00207955)*x386))+((cj0*py*sj1))+(((-1.0)*cj1*pz))+(((-0.00082188)*x387))+(((-1.0)*px*sj0*sj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs((((r01*sj0))+((cj0*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj0))+((cj0*r00))))+IKsqr((((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r01*sj0))+((cj0*r00))), (((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(((-1.0)*(IKsin(j4))))+((cj0*r00)));
evalcond[1]=(((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x388=((1.0)*r00);
if( IKabs(((((-1.0)*r01*sj0))+(((-1.0)*cj0*x388)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*sj0*x388)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj0))+(((-1.0)*cj0*x388))))+IKsqr((((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*sj0*x388))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*r01*sj0))+(((-1.0)*cj0*x388))), (((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*sj0*x388))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(IKsin(j4))+((cj0*r00)));
evalcond[1]=(((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x389=(r00*sj0);
IkReal x390=(cj0*r01);
if( IKabs((((cj1*r02))+(((-1.0)*sj1*x390))+((sj1*x389)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r02*sj1))+((cj1*x390))+(((-1.0)*cj1*x389)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r02))+(((-1.0)*sj1*x390))+((sj1*x389))))+IKsqr((((r02*sj1))+((cj1*x390))+(((-1.0)*cj1*x389))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((cj1*r02))+(((-1.0)*sj1*x390))+((sj1*x389))), (((r02*sj1))+((cj1*x390))+(((-1.0)*cj1*x389))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x391=((1.0)*cj1);
IkReal x392=(cj0*r01);
IkReal x393=(r00*sj0);
evalcond[0]=(((sj1*x392))+(((-1.0)*r02*x391))+(IKsin(j4))+(((-1.0)*sj1*x393)));
evalcond[1]=(((r02*sj1))+(((-1.0)*x391*x393))+((cj1*x392))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x394=((1.0)*cj1);
IkReal x395=(cj0*r01);
IkReal x396=(r00*sj0);
if( IKabs((((sj1*x395))+(((-1.0)*r02*x394))+(((-1.0)*sj1*x396)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x394*x396))+((r02*sj1))+((cj1*x395)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj1*x395))+(((-1.0)*r02*x394))+(((-1.0)*sj1*x396))))+IKsqr(((((-1.0)*x394*x396))+((r02*sj1))+((cj1*x395))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((sj1*x395))+(((-1.0)*r02*x394))+(((-1.0)*sj1*x396))), ((((-1.0)*x394*x396))+((r02*sj1))+((cj1*x395))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x397=((1.0)*cj1);
IkReal x398=(cj0*r01);
IkReal x399=(r00*sj0);
evalcond[0]=(((r02*sj1))+(((-1.0)*x397*x399))+((cj1*x398))+(((-1.0)*(IKcos(j4)))));
evalcond[1]=((((-1.0)*(IKsin(j4))))+((sj1*x398))+(((-1.0)*r02*x397))+(((-1.0)*sj1*x399)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x400=(r00*sj0);
IkReal x401=(cj0*r01);
CheckValue<IkReal> x402=IKPowWithIntegerCheck(cj3,-1);
if(!x402.valid){
continue;
}
if( IKabs(((x402.value)*(((((-1.0)*sj1*x401))+((sj1*x400))+((cj1*r02)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r02*sj1))+(((-1.0)*cj1*x400))+((cj1*x401)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x402.value)*(((((-1.0)*sj1*x401))+((sj1*x400))+((cj1*r02))))))+IKsqr((((r02*sj1))+(((-1.0)*cj1*x400))+((cj1*x401))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x402.value)*(((((-1.0)*sj1*x401))+((sj1*x400))+((cj1*r02))))), (((r02*sj1))+(((-1.0)*cj1*x400))+((cj1*x401))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x403=IKsin(j4);
IkReal x404=((1.0)*cj1);
IkReal x405=(cj0*r01);
IkReal x406=(r00*sj0);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x403))+((cj0*r00)));
evalcond[1]=(((r02*sj1))+(((-1.0)*x404*x406))+((cj1*x405))+(((-1.0)*(IKcos(j4)))));
evalcond[2]=((((-1.0)*sj1*x406))+((sj1*x405))+(((-1.0)*r02*x404))+((cj3*x403)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x407=IKPowWithIntegerCheck(sj3,-1);
if(!x407.valid){
continue;
}
if( IKabs(((x407.value)*((((r01*sj0))+((cj0*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x407.value)*((((r01*sj0))+((cj0*r00))))))+IKsqr((((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x407.value)*((((r01*sj0))+((cj0*r00))))), (((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x408=IKsin(j4);
IkReal x409=((1.0)*cj1);
IkReal x410=(cj0*r01);
IkReal x411=(r00*sj0);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x408))+((cj0*r00)));
evalcond[1]=(((r02*sj1))+(((-1.0)*(IKcos(j4))))+((cj1*x410))+(((-1.0)*x409*x411)));
evalcond[2]=((((-1.0)*sj1*x411))+((sj1*x410))+(((-1.0)*r02*x409))+((cj3*x408)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j3, j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x412=((8218800000000.0)*px);
IkReal x413=(cj0*sj2);
IkReal x414=(sj0*sj1);
IkReal x415=((20795500000000.0)*px);
IkReal x416=(cj1*pz);
IkReal x417=(py*sj0*sj2);
IkReal x418=(cj0*py*sj1);
CheckValue<IkReal> x419=IKPowWithIntegerCheck(IKsign(sj2),-1);
if(!x419.valid){
continue;
}
CheckValue<IkReal> x420 = IKatan2WithCheck(IkReal(((4575010000000.0)+(((4678987500000.0)*cj2))+(((-1.0)*x412*x413))+(((-33372200000.0)*sj2))+(((-8218800000000.0)*x417))+(((20795500000000.0)*x418))+(((-1.0)*x414*x415))+(((-20795500000000.0)*x416)))),IkReal(((-1808136000000.0)+(((-1849230000000.0)*cj2))+(((8218800000000.0)*x416))+(((-8218800000000.0)*x418))+((x412*x414))+(((-1.0)*x413*x415))+(((37233100000.0)*sj2))+(((-20795500000000.0)*x417)))),IKFAST_ATAN2_MAGTHRESH);
if(!x420.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x419.value)))+(x420.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x421=IKsin(j3);
IkReal x422=IKcos(j3);
IkReal x423=((1.0)*cj1);
IkReal x424=(px*sj0);
IkReal x425=(cj0*py);
IkReal x426=((0.00082188)*x422);
IkReal x427=((0.00207955)*x421);
evalcond[0]=((-0.001)+(((0.00207955)*x422))+(((0.00082188)*x421))+((cj0*px))+((py*sj0)));
evalcond[1]=((((-1.0)*cj2*x426))+(((0.002)*cj2))+((pz*sj1))+((cj2*x427))+(((-1.0)*x423*x424))+(((0.225)*sj2))+((cj1*x425)));
evalcond[2]=((0.22)+(((0.225)*cj2))+(((-1.0)*sj2*x427))+(((-0.002)*sj2))+(((-1.0)*sj1*x424))+((sj2*x426))+(((-1.0)*pz*x423))+((sj1*x425)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=cj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=sj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x428=((1.0)*sj2);
IkReal x429=(r02*sj1);
IkReal x430=(cj0*r01);
IkReal x431=(r00*sj0);
IkReal x432=(cj1*r02);
IkReal x433=((1.0)*cj2);
if( IKabs(((((-1.0)*sj1*x428*x431))+(((-1.0)*x429*x433))+(((-1.0)*cj1*x430*x433))+((sj1*sj2*x430))+(((-1.0)*x428*x432))+((cj1*cj2*x431)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj2*sj1*x431))+(((-1.0)*cj1*x428*x430))+(((-1.0)*x428*x429))+((cj2*x432))+((cj1*sj2*x431))+(((-1.0)*sj1*x430*x433)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj1*x428*x431))+(((-1.0)*x429*x433))+(((-1.0)*cj1*x430*x433))+((sj1*sj2*x430))+(((-1.0)*x428*x432))+((cj1*cj2*x431))))+IKsqr((((cj2*sj1*x431))+(((-1.0)*cj1*x428*x430))+(((-1.0)*x428*x429))+((cj2*x432))+((cj1*sj2*x431))+(((-1.0)*sj1*x430*x433))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*sj1*x428*x431))+(((-1.0)*x429*x433))+(((-1.0)*cj1*x430*x433))+((sj1*sj2*x430))+(((-1.0)*x428*x432))+((cj1*cj2*x431))), (((cj2*sj1*x431))+(((-1.0)*cj1*x428*x430))+(((-1.0)*x428*x429))+((cj2*x432))+((cj1*sj2*x431))+(((-1.0)*sj1*x430*x433))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x434=IKcos(j4);
IkReal x435=IKsin(j4);
IkReal x436=((1.0)*cj1);
IkReal x437=(cj0*r01);
IkReal x438=(r00*sj0);
evalcond[0]=(((cj1*x437))+(((-1.0)*x436*x438))+((r02*sj1))+((sj2*x434))+((cj2*x435)));
evalcond[1]=((((-1.0)*sj1*x438))+(((-1.0)*r02*x436))+(((-1.0)*sj2*x435))+((cj2*x434))+((sj1*x437)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x439=((1.0)*sj2);
IkReal x440=(r02*sj1);
IkReal x441=(cj0*r01);
IkReal x442=((1.0)*cj2);
IkReal x443=(cj1*r02);
IkReal x444=(cj1*r00*sj0);
IkReal x445=(r00*sj0*sj1);
if( IKabs((((cj1*cj2*x441))+(((-1.0)*sj1*x439*x441))+((cj2*x440))+((sj2*x445))+((sj2*x443))+(((-1.0)*x442*x444)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj1*x441*x442))+(((-1.0)*x439*x440))+((cj2*x443))+((cj2*x445))+((sj2*x444))+(((-1.0)*cj1*x439*x441)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*cj2*x441))+(((-1.0)*sj1*x439*x441))+((cj2*x440))+((sj2*x445))+((sj2*x443))+(((-1.0)*x442*x444))))+IKsqr(((((-1.0)*sj1*x441*x442))+(((-1.0)*x439*x440))+((cj2*x443))+((cj2*x445))+((sj2*x444))+(((-1.0)*cj1*x439*x441))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((cj1*cj2*x441))+(((-1.0)*sj1*x439*x441))+((cj2*x440))+((sj2*x445))+((sj2*x443))+(((-1.0)*x442*x444))), ((((-1.0)*sj1*x441*x442))+(((-1.0)*x439*x440))+((cj2*x443))+((cj2*x445))+((sj2*x444))+(((-1.0)*cj1*x439*x441))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x446=IKcos(j4);
IkReal x447=IKsin(j4);
IkReal x448=((1.0)*cj1);
IkReal x449=(cj0*r01);
IkReal x450=(r00*sj0);
evalcond[0]=(((cj1*x449))+((r02*sj1))+((sj2*x446))+(((-1.0)*cj2*x447))+(((-1.0)*x448*x450)));
evalcond[1]=(((sj1*x449))+(((-1.0)*r02*x448))+((cj2*x446))+((sj2*x447))+(((-1.0)*sj1*x450)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj2=0;
cj2=1.0;
j2=0;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=0;
cj2=1.0;
j2=0;
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs((((r01*sj0))+((cj0*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj0))+((cj0*r00))))+IKsqr((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r01*sj0))+((cj0*r00))), (((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(((-1.0)*(IKsin(j4))))+((cj0*r00)));
evalcond[1]=((((-1.0)*r00*sj0*sj1))+(IKcos(j4))+((cj0*r01*sj1))+(((-1.0)*cj1*r02)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x451=((1.0)*cj0);
if( IKabs(((((-1.0)*r01*sj0))+(((-1.0)*r00*x451)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*r01*sj1*x451)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj0))+(((-1.0)*r00*x451))))+IKsqr((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*r01*sj1*x451))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*r01*sj0))+(((-1.0)*r00*x451))), (((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*r01*sj1*x451))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(IKsin(j4))+((cj0*r00)));
evalcond[1]=((((-1.0)*r00*sj0*sj1))+(IKcos(j4))+((cj0*r01*sj1))+(((-1.0)*cj1*r02)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x452=(r00*sj0);
IkReal x453=((1.0)*cj0*r01);
if( IKabs((((cj1*x452))+(((-1.0)*cj1*x453))+(((-1.0)*r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*r02))+(((-1.0)*sj1*x453))+((sj1*x452)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*x452))+(((-1.0)*cj1*x453))+(((-1.0)*r02*sj1))))+IKsqr((((cj1*r02))+(((-1.0)*sj1*x453))+((sj1*x452))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((cj1*x452))+(((-1.0)*cj1*x453))+(((-1.0)*r02*sj1))), (((cj1*r02))+(((-1.0)*sj1*x453))+((sj1*x452))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x454=((1.0)*cj1);
IkReal x455=(cj0*r01);
IkReal x456=(r00*sj0);
evalcond[0]=(((cj1*x455))+(IKsin(j4))+(((-1.0)*x454*x456))+((r02*sj1)));
evalcond[1]=((IKcos(j4))+((sj1*x455))+(((-1.0)*r02*x454))+(((-1.0)*sj1*x456)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x457=(r00*sj0);
IkReal x458=(cj0*r01);
if( IKabs((((cj1*x458))+(((-1.0)*cj1*x457))+((r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*r02))+((sj1*x457))+(((-1.0)*sj1*x458)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*x458))+(((-1.0)*cj1*x457))+((r02*sj1))))+IKsqr((((cj1*r02))+((sj1*x457))+(((-1.0)*sj1*x458))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((cj1*x458))+(((-1.0)*cj1*x457))+((r02*sj1))), (((cj1*r02))+((sj1*x457))+(((-1.0)*sj1*x458))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x459=((1.0)*cj1);
IkReal x460=(cj0*r01);
IkReal x461=(r00*sj0);
evalcond[0]=((IKcos(j4))+((sj1*x460))+(((-1.0)*r02*x459))+(((-1.0)*sj1*x461)));
evalcond[1]=((((-1.0)*(IKsin(j4))))+((cj1*x460))+(((-1.0)*x459*x461))+((r02*sj1)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x462=(r00*sj0);
IkReal x463=((1.0)*cj0*r01);
CheckValue<IkReal> x464=IKPowWithIntegerCheck(cj3,-1);
if(!x464.valid){
continue;
}
if( IKabs(((x464.value)*((((cj1*x462))+(((-1.0)*r02*sj1))+(((-1.0)*cj1*x463)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*r02))+(((-1.0)*sj1*x463))+((sj1*x462)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x464.value)*((((cj1*x462))+(((-1.0)*r02*sj1))+(((-1.0)*cj1*x463))))))+IKsqr((((cj1*r02))+(((-1.0)*sj1*x463))+((sj1*x462))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x464.value)*((((cj1*x462))+(((-1.0)*r02*sj1))+(((-1.0)*cj1*x463))))), (((cj1*r02))+(((-1.0)*sj1*x463))+((sj1*x462))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x465=IKsin(j4);
IkReal x466=((1.0)*cj1);
IkReal x467=(cj0*r01);
IkReal x468=(r00*sj0);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x465))+((cj0*r00)));
evalcond[1]=((IKcos(j4))+((sj1*x467))+(((-1.0)*r02*x466))+(((-1.0)*sj1*x468)));
evalcond[2]=((((-1.0)*x466*x468))+((cj1*x467))+((r02*sj1))+((cj3*x465)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x469=IKPowWithIntegerCheck(sj3,-1);
if(!x469.valid){
continue;
}
if( IKabs(((x469.value)*((((r01*sj0))+((cj0*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x469.value)*((((r01*sj0))+((cj0*r00))))))+IKsqr((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x469.value)*((((r01*sj0))+((cj0*r00))))), (((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x470=IKsin(j4);
IkReal x471=((1.0)*cj1);
IkReal x472=(cj0*r01);
IkReal x473=(r00*sj0);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x470))+((cj0*r00)));
evalcond[1]=((IKcos(j4))+(((-1.0)*sj1*x473))+((sj1*x472))+(((-1.0)*r02*x471)));
evalcond[2]=(((cj3*x470))+((cj1*x472))+((r02*sj1))+(((-1.0)*x471*x473)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs((((r01*sj0))+((cj0*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj0))+((cj0*r00))))+IKsqr(((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r01*sj0))+((cj0*r00))), ((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(((-1.0)*(IKsin(j4))))+((cj0*r00)));
evalcond[1]=((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*(IKcos(j4))))+(((-1.0)*cj1*r02)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x474=((1.0)*r00);
if( IKabs(((((-1.0)*r01*sj0))+(((-1.0)*cj0*x474)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj0*sj1*x474))+((cj0*r01*sj1))+(((-1.0)*cj1*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj0))+(((-1.0)*cj0*x474))))+IKsqr(((((-1.0)*sj0*sj1*x474))+((cj0*r01*sj1))+(((-1.0)*cj1*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*r01*sj0))+(((-1.0)*cj0*x474))), ((((-1.0)*sj0*sj1*x474))+((cj0*r01*sj1))+(((-1.0)*cj1*r02))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(IKsin(j4))+((cj0*r00)));
evalcond[1]=((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*(IKcos(j4))))+(((-1.0)*cj1*r02)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x475=((1.0)*cj1);
IkReal x476=(cj0*r01);
IkReal x477=(r00*sj0);
if( IKabs(((((-1.0)*x475*x477))+((cj1*x476))+((r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj1*x477))+((sj1*x476))+(((-1.0)*r02*x475)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x475*x477))+((cj1*x476))+((r02*sj1))))+IKsqr(((((-1.0)*sj1*x477))+((sj1*x476))+(((-1.0)*r02*x475))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*x475*x477))+((cj1*x476))+((r02*sj1))), ((((-1.0)*sj1*x477))+((sj1*x476))+(((-1.0)*r02*x475))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x478=((1.0)*cj1);
IkReal x479=(cj0*r01);
IkReal x480=(r00*sj0);
evalcond[0]=((((-1.0)*(IKsin(j4))))+((cj1*x479))+((r02*sj1))+(((-1.0)*x478*x480)));
evalcond[1]=(((sj1*x479))+(((-1.0)*sj1*x480))+(((-1.0)*(IKcos(j4))))+(((-1.0)*r02*x478)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x481=((1.0)*cj1);
IkReal x482=(cj0*r01);
IkReal x483=((1.0)*sj1);
IkReal x484=(r00*sj0);
if( IKabs(((((-1.0)*x481*x482))+((cj1*x484))+(((-1.0)*r02*x483)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x483*x484))+((sj1*x482))+(((-1.0)*r02*x481)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x481*x482))+((cj1*x484))+(((-1.0)*r02*x483))))+IKsqr(((((-1.0)*x483*x484))+((sj1*x482))+(((-1.0)*r02*x481))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*x481*x482))+((cj1*x484))+(((-1.0)*r02*x483))), ((((-1.0)*x483*x484))+((sj1*x482))+(((-1.0)*r02*x481))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x485=((1.0)*cj1);
IkReal x486=(cj0*r01);
IkReal x487=(r00*sj0);
evalcond[0]=((IKsin(j4))+((r02*sj1))+((cj1*x486))+(((-1.0)*x485*x487)));
evalcond[1]=(((sj1*x486))+(((-1.0)*sj1*x487))+(((-1.0)*(IKcos(j4))))+(((-1.0)*r02*x485)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x488=((1.0)*cj1);
IkReal x489=(cj0*r01);
IkReal x490=(r00*sj0);
CheckValue<IkReal> x491=IKPowWithIntegerCheck(cj3,-1);
if(!x491.valid){
continue;
}
if( IKabs(((x491.value)*(((((-1.0)*x488*x490))+((r02*sj1))+((cj1*x489)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((sj1*x489))+(((-1.0)*sj1*x490))+(((-1.0)*r02*x488)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x491.value)*(((((-1.0)*x488*x490))+((r02*sj1))+((cj1*x489))))))+IKsqr((((sj1*x489))+(((-1.0)*sj1*x490))+(((-1.0)*r02*x488))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x491.value)*(((((-1.0)*x488*x490))+((r02*sj1))+((cj1*x489))))), (((sj1*x489))+(((-1.0)*sj1*x490))+(((-1.0)*r02*x488))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x492=IKsin(j4);
IkReal x493=((1.0)*cj1);
IkReal x494=(cj0*r01);
IkReal x495=(r00*sj0);
IkReal x496=((1.0)*x492);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x496))+((cj0*r00)));
evalcond[1]=((((-1.0)*cj3*x496))+(((-1.0)*x493*x495))+((r02*sj1))+((cj1*x494)));
evalcond[2]=((((-1.0)*r02*x493))+((sj1*x494))+(((-1.0)*sj1*x495))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x497=IKPowWithIntegerCheck(sj3,-1);
if(!x497.valid){
continue;
}
if( IKabs(((x497.value)*((((r01*sj0))+((cj0*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x497.value)*((((r01*sj0))+((cj0*r00))))))+IKsqr(((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x497.value)*((((r01*sj0))+((cj0*r00))))), ((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x498=IKsin(j4);
IkReal x499=((1.0)*cj1);
IkReal x500=(cj0*r01);
IkReal x501=(r00*sj0);
IkReal x502=((1.0)*x498);
evalcond[0]=((((-1.0)*sj3*x502))+((r01*sj0))+((cj0*r00)));
evalcond[1]=((((-1.0)*x499*x501))+((cj1*x500))+((r02*sj1))+(((-1.0)*cj3*x502)));
evalcond[2]=((((-1.0)*r02*x499))+(((-1.0)*sj1*x501))+((sj1*x500))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs((((r01*sj0))+((cj0*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj0))+((cj0*r00))))+IKsqr(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r01*sj0))+((cj0*r00))), ((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(((-1.0)*(IKsin(j4))))+((cj0*r00)));
evalcond[1]=(((cj0*cj1*r01))+((r02*sj1))+(IKcos(j4))+(((-1.0)*cj1*r00*sj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x503=((1.0)*cj0);
if( IKabs(((((-1.0)*r01*sj0))+(((-1.0)*r00*x503)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r02*sj1))+((cj1*r00*sj0))+(((-1.0)*cj1*r01*x503)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj0))+(((-1.0)*r00*x503))))+IKsqr(((((-1.0)*r02*sj1))+((cj1*r00*sj0))+(((-1.0)*cj1*r01*x503))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*r01*sj0))+(((-1.0)*r00*x503))), ((((-1.0)*r02*sj1))+((cj1*r00*sj0))+(((-1.0)*cj1*r01*x503))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(IKsin(j4))+((cj0*r00)));
evalcond[1]=(((cj0*cj1*r01))+((r02*sj1))+(IKcos(j4))+(((-1.0)*cj1*r00*sj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x504=((1.0)*cj1);
IkReal x505=(cj0*r01);
IkReal x506=((1.0)*sj1);
IkReal x507=(r00*sj0);
if( IKabs(((((-1.0)*x506*x507))+((sj1*x505))+(((-1.0)*r02*x504)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*x507))+(((-1.0)*x504*x505))+(((-1.0)*r02*x506)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x506*x507))+((sj1*x505))+(((-1.0)*r02*x504))))+IKsqr((((cj1*x507))+(((-1.0)*x504*x505))+(((-1.0)*r02*x506))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*x506*x507))+((sj1*x505))+(((-1.0)*r02*x504))), (((cj1*x507))+(((-1.0)*x504*x505))+(((-1.0)*r02*x506))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x508=((1.0)*cj1);
IkReal x509=(cj0*r01);
IkReal x510=(r00*sj0);
evalcond[0]=(((cj1*x509))+((r02*sj1))+(IKcos(j4))+(((-1.0)*x508*x510)));
evalcond[1]=((((-1.0)*(IKsin(j4))))+((sj1*x509))+(((-1.0)*sj1*x510))+(((-1.0)*r02*x508)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x511=(r00*sj0);
IkReal x512=((1.0)*cj0*r01);
if( IKabs((((cj1*r02))+(((-1.0)*sj1*x512))+((sj1*x511)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj1*x512))+(((-1.0)*r02*sj1))+((cj1*x511)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r02))+(((-1.0)*sj1*x512))+((sj1*x511))))+IKsqr(((((-1.0)*cj1*x512))+(((-1.0)*r02*sj1))+((cj1*x511))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((cj1*r02))+(((-1.0)*sj1*x512))+((sj1*x511))), ((((-1.0)*cj1*x512))+(((-1.0)*r02*sj1))+((cj1*x511))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x513=((1.0)*cj1);
IkReal x514=(cj0*r01);
IkReal x515=(r00*sj0);
evalcond[0]=((((-1.0)*x513*x515))+((r02*sj1))+(IKcos(j4))+((cj1*x514)));
evalcond[1]=((IKsin(j4))+(((-1.0)*r02*x513))+((sj1*x514))+(((-1.0)*sj1*x515)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x516=((1.0)*cj1);
IkReal x517=(cj0*r01);
IkReal x518=((1.0)*sj1);
IkReal x519=(r00*sj0);
CheckValue<IkReal> x520=IKPowWithIntegerCheck(cj3,-1);
if(!x520.valid){
continue;
}
if( IKabs(((x520.value)*(((((-1.0)*x518*x519))+(((-1.0)*r02*x516))+((sj1*x517)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x516*x517))+((cj1*x519))+(((-1.0)*r02*x518)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x520.value)*(((((-1.0)*x518*x519))+(((-1.0)*r02*x516))+((sj1*x517))))))+IKsqr(((((-1.0)*x516*x517))+((cj1*x519))+(((-1.0)*r02*x518))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x520.value)*(((((-1.0)*x518*x519))+(((-1.0)*r02*x516))+((sj1*x517))))), ((((-1.0)*x516*x517))+((cj1*x519))+(((-1.0)*r02*x518))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x521=IKsin(j4);
IkReal x522=((1.0)*cj1);
IkReal x523=(cj0*r01);
IkReal x524=(r00*sj0);
IkReal x525=((1.0)*x521);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x525))+((cj0*r00)));
evalcond[1]=(((r02*sj1))+(IKcos(j4))+((cj1*x523))+(((-1.0)*x522*x524)));
evalcond[2]=(((sj1*x523))+(((-1.0)*cj3*x525))+(((-1.0)*sj1*x524))+(((-1.0)*r02*x522)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x526=IKPowWithIntegerCheck(sj3,-1);
if(!x526.valid){
continue;
}
if( IKabs(((x526.value)*((((r01*sj0))+((cj0*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x526.value)*((((r01*sj0))+((cj0*r00))))))+IKsqr(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x526.value)*((((r01*sj0))+((cj0*r00))))), ((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x527=IKsin(j4);
IkReal x528=((1.0)*cj1);
IkReal x529=(cj0*r01);
IkReal x530=(r00*sj0);
IkReal x531=((1.0)*x527);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x531))+((cj0*r00)));
evalcond[1]=((((-1.0)*x528*x530))+((r02*sj1))+(IKcos(j4))+((cj1*x529)));
evalcond[2]=(((sj1*x529))+(((-1.0)*cj3*x531))+(((-1.0)*sj1*x530))+(((-1.0)*r02*x528)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs((((r01*sj0))+((cj0*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj0))+((cj0*r00))))+IKsqr((((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r01*sj0))+((cj0*r00))), (((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(((-1.0)*(IKsin(j4))))+((cj0*r00)));
evalcond[1]=(((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x532=((1.0)*r00);
if( IKabs(((((-1.0)*r01*sj0))+(((-1.0)*cj0*x532)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj1*sj0*x532))+((cj0*cj1*r01))+((r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj0))+(((-1.0)*cj0*x532))))+IKsqr(((((-1.0)*cj1*sj0*x532))+((cj0*cj1*r01))+((r02*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*r01*sj0))+(((-1.0)*cj0*x532))), ((((-1.0)*cj1*sj0*x532))+((cj0*cj1*r01))+((r02*sj1))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(IKsin(j4))+((cj0*r00)));
evalcond[1]=(((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x533=(r00*sj0);
IkReal x534=(cj0*r01);
if( IKabs((((sj1*x533))+((cj1*r02))+(((-1.0)*sj1*x534)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r02*sj1))+((cj1*x534))+(((-1.0)*cj1*x533)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj1*x533))+((cj1*r02))+(((-1.0)*sj1*x534))))+IKsqr((((r02*sj1))+((cj1*x534))+(((-1.0)*cj1*x533))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((sj1*x533))+((cj1*r02))+(((-1.0)*sj1*x534))), (((r02*sj1))+((cj1*x534))+(((-1.0)*cj1*x533))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x535=((1.0)*cj1);
IkReal x536=(cj0*r01);
IkReal x537=(r00*sj0);
evalcond[0]=(((sj1*x536))+(((-1.0)*sj1*x537))+(IKsin(j4))+(((-1.0)*r02*x535)));
evalcond[1]=(((r02*sj1))+((cj1*x536))+(((-1.0)*x535*x537))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x538=((1.0)*cj1);
IkReal x539=(cj0*r01);
IkReal x540=(r00*sj0);
if( IKabs((((sj1*x539))+(((-1.0)*r02*x538))+(((-1.0)*sj1*x540)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x538*x540))+((r02*sj1))+((cj1*x539)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((sj1*x539))+(((-1.0)*r02*x538))+(((-1.0)*sj1*x540))))+IKsqr(((((-1.0)*x538*x540))+((r02*sj1))+((cj1*x539))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((sj1*x539))+(((-1.0)*r02*x538))+(((-1.0)*sj1*x540))), ((((-1.0)*x538*x540))+((r02*sj1))+((cj1*x539))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x541=((1.0)*cj1);
IkReal x542=(cj0*r01);
IkReal x543=(r00*sj0);
evalcond[0]=((((-1.0)*x541*x543))+((r02*sj1))+((cj1*x542))+(((-1.0)*(IKcos(j4)))));
evalcond[1]=(((sj1*x542))+(((-1.0)*(IKsin(j4))))+(((-1.0)*sj1*x543))+(((-1.0)*r02*x541)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x544=(r00*sj0);
IkReal x545=(cj0*r01);
CheckValue<IkReal> x546=IKPowWithIntegerCheck(cj3,-1);
if(!x546.valid){
continue;
}
if( IKabs(((x546.value)*((((sj1*x544))+((cj1*r02))+(((-1.0)*sj1*x545)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r02*sj1))+((cj1*x545))+(((-1.0)*cj1*x544)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x546.value)*((((sj1*x544))+((cj1*r02))+(((-1.0)*sj1*x545))))))+IKsqr((((r02*sj1))+((cj1*x545))+(((-1.0)*cj1*x544))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x546.value)*((((sj1*x544))+((cj1*r02))+(((-1.0)*sj1*x545))))), (((r02*sj1))+((cj1*x545))+(((-1.0)*cj1*x544))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x547=IKsin(j4);
IkReal x548=((1.0)*cj1);
IkReal x549=(cj0*r01);
IkReal x550=(r00*sj0);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x547))+((cj0*r00)));
evalcond[1]=((((-1.0)*x548*x550))+((r02*sj1))+((cj1*x549))+(((-1.0)*(IKcos(j4)))));
evalcond[2]=(((sj1*x549))+(((-1.0)*r02*x548))+(((-1.0)*sj1*x550))+((cj3*x547)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x551=IKPowWithIntegerCheck(sj3,-1);
if(!x551.valid){
continue;
}
if( IKabs(((x551.value)*((((r01*sj0))+((cj0*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x551.value)*((((r01*sj0))+((cj0*r00))))))+IKsqr((((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x551.value)*((((r01*sj0))+((cj0*r00))))), (((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x552=IKsin(j4);
IkReal x553=((1.0)*cj1);
IkReal x554=(cj0*r01);
IkReal x555=(r00*sj0);
evalcond[0]=((((-1.0)*sj3*x552))+((r01*sj0))+((cj0*r00)));
evalcond[1]=((((-1.0)*x553*x555))+((cj1*x554))+((r02*sj1))+(((-1.0)*(IKcos(j4)))));
evalcond[2]=(((sj1*x554))+(((-1.0)*r02*x553))+(((-1.0)*sj1*x555))+((cj3*x552)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
j4eval[0]=cj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
j4eval[0]=sj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x556=IKPowWithIntegerCheck(sj2,-1);
if(!x556.valid){
continue;
}
if( IKabs((((r01*sj0))+((cj0*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x556.value)*(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj0))+((cj0*r00))))+IKsqr(((x556.value)*(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r01*sj0))+((cj0*r00))), ((x556.value)*(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x557=IKcos(j4);
IkReal x558=((1.0)*cj1);
IkReal x559=(cj0*r01);
IkReal x560=(r00*sj0);
evalcond[0]=(((r01*sj0))+(((-1.0)*(IKsin(j4))))+((cj0*r00)));
evalcond[1]=((((-1.0)*x558*x560))+((sj2*x557))+((cj1*x559))+((r02*sj1)));
evalcond[2]=(((sj1*x559))+(((-1.0)*sj1*x560))+(((-1.0)*r02*x558))+((cj2*x557)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x561=IKPowWithIntegerCheck(cj2,-1);
if(!x561.valid){
continue;
}
if( IKabs((((r01*sj0))+((cj0*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x561.value)*((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj0))+((cj0*r00))))+IKsqr(((x561.value)*((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r01*sj0))+((cj0*r00))), ((x561.value)*((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x562=IKcos(j4);
IkReal x563=((1.0)*cj1);
IkReal x564=(cj0*r01);
IkReal x565=(r00*sj0);
evalcond[0]=(((r01*sj0))+(((-1.0)*(IKsin(j4))))+((cj0*r00)));
evalcond[1]=(((cj1*x564))+((r02*sj1))+(((-1.0)*x563*x565))+((sj2*x562)));
evalcond[2]=((((-1.0)*sj1*x565))+((cj2*x562))+((sj1*x564))+(((-1.0)*r02*x563)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
j4eval[0]=cj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
j4eval[0]=sj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x566=((1.0)*cj0);
CheckValue<IkReal> x567=IKPowWithIntegerCheck(sj2,-1);
if(!x567.valid){
continue;
}
if( IKabs(((((-1.0)*r01*sj0))+(((-1.0)*r00*x566)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x567.value)*(((((-1.0)*r02*sj1))+((cj1*r00*sj0))+(((-1.0)*cj1*r01*x566)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj0))+(((-1.0)*r00*x566))))+IKsqr(((x567.value)*(((((-1.0)*r02*sj1))+((cj1*r00*sj0))+(((-1.0)*cj1*r01*x566))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*r01*sj0))+(((-1.0)*r00*x566))), ((x567.value)*(((((-1.0)*r02*sj1))+((cj1*r00*sj0))+(((-1.0)*cj1*r01*x566))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x568=IKcos(j4);
IkReal x569=((1.0)*cj1);
IkReal x570=(cj0*r01);
IkReal x571=(r00*sj0);
evalcond[0]=(((r01*sj0))+(IKsin(j4))+((cj0*r00)));
evalcond[1]=((((-1.0)*x569*x571))+((r02*sj1))+((cj1*x570))+((sj2*x568)));
evalcond[2]=(((sj1*x570))+((cj2*x568))+(((-1.0)*sj1*x571))+(((-1.0)*r02*x569)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x572=((1.0)*cj0);
CheckValue<IkReal> x573=IKPowWithIntegerCheck(cj2,-1);
if(!x573.valid){
continue;
}
if( IKabs(((((-1.0)*r01*sj0))+(((-1.0)*r00*x572)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x573.value)*((((r00*sj0*sj1))+(((-1.0)*r01*sj1*x572))+((cj1*r02)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj0))+(((-1.0)*r00*x572))))+IKsqr(((x573.value)*((((r00*sj0*sj1))+(((-1.0)*r01*sj1*x572))+((cj1*r02))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*r01*sj0))+(((-1.0)*r00*x572))), ((x573.value)*((((r00*sj0*sj1))+(((-1.0)*r01*sj1*x572))+((cj1*r02))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x574=IKcos(j4);
IkReal x575=((1.0)*cj1);
IkReal x576=(cj0*r01);
IkReal x577=(r00*sj0);
evalcond[0]=(((r01*sj0))+(IKsin(j4))+((cj0*r00)));
evalcond[1]=(((r02*sj1))+(((-1.0)*x575*x577))+((sj2*x574))+((cj1*x576)));
evalcond[2]=(((sj1*x576))+((cj2*x574))+(((-1.0)*sj1*x577))+(((-1.0)*r02*x575)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x583=IKPowWithIntegerCheck(sj3,-1);
if(!x583.valid){
continue;
}
IkReal x578=x583.value;
IkReal x579=(cj1*sj3);
IkReal x580=((1.0)*r01);
IkReal x581=(cj2*cj3);
IkReal x582=(cj0*r00);
CheckValue<IkReal> x584=IKPowWithIntegerCheck(sj2,-1);
if(!x584.valid){
continue;
}
if( IKabs((x578*((((r01*sj0))+x582)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x578*(x584.value)*(((((-1.0)*x581*x582))+(((-1.0)*r02*sj1*sj3))+(((-1.0)*cj0*x579*x580))+((r00*sj0*x579))+(((-1.0)*sj0*x580*x581)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x578*((((r01*sj0))+x582))))+IKsqr((x578*(x584.value)*(((((-1.0)*x581*x582))+(((-1.0)*r02*sj1*sj3))+(((-1.0)*cj0*x579*x580))+((r00*sj0*x579))+(((-1.0)*sj0*x580*x581))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x578*((((r01*sj0))+x582))), (x578*(x584.value)*(((((-1.0)*x581*x582))+(((-1.0)*r02*sj1*sj3))+(((-1.0)*cj0*x579*x580))+((r00*sj0*x579))+(((-1.0)*sj0*x580*x581))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x585=IKsin(j4);
IkReal x586=IKcos(j4);
IkReal x587=((1.0)*cj1);
IkReal x588=(cj0*r01);
IkReal x589=(r00*sj0);
IkReal x590=(cj3*x585);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x585))+((cj0*r00)));
evalcond[1]=(((sj2*x586))+(((-1.0)*x587*x589))+((r02*sj1))+((cj2*x590))+((cj1*x588)));
evalcond[2]=((((-1.0)*r02*x587))+((sj1*x588))+(((-1.0)*sj1*x589))+(((-1.0)*sj2*x590))+((cj2*x586)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x596=IKPowWithIntegerCheck(sj3,-1);
if(!x596.valid){
continue;
}
IkReal x591=x596.value;
IkReal x592=(sj1*sj3);
IkReal x593=(cj0*r00);
IkReal x594=(r01*sj0);
IkReal x595=(cj3*sj2);
CheckValue<IkReal> x597=IKPowWithIntegerCheck(cj2,-1);
if(!x597.valid){
continue;
}
if( IKabs((x591*((x594+x593)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x591*(x597.value)*((((r00*sj0*x592))+((x594*x595))+(((-1.0)*cj0*r01*x592))+((x593*x595))+((cj1*r02*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x591*((x594+x593))))+IKsqr((x591*(x597.value)*((((r00*sj0*x592))+((x594*x595))+(((-1.0)*cj0*r01*x592))+((x593*x595))+((cj1*r02*sj3))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x591*((x594+x593))), (x591*(x597.value)*((((r00*sj0*x592))+((x594*x595))+(((-1.0)*cj0*r01*x592))+((x593*x595))+((cj1*r02*sj3))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x598=IKsin(j4);
IkReal x599=IKcos(j4);
IkReal x600=((1.0)*cj1);
IkReal x601=(cj0*r01);
IkReal x602=(r00*sj0);
IkReal x603=(cj3*x598);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x598))+((cj0*r00)));
evalcond[1]=(((cj2*x603))+((r02*sj1))+((cj1*x601))+(((-1.0)*x600*x602))+((sj2*x599)));
evalcond[2]=((((-1.0)*sj1*x602))+((sj1*x601))+(((-1.0)*sj2*x603))+((cj2*x599))+(((-1.0)*r02*x600)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x604=((1.0)*sj2);
IkReal x605=(r02*sj1);
IkReal x606=(cj0*r01);
IkReal x607=(r00*sj0);
IkReal x608=(cj1*r02);
IkReal x609=((1.0)*cj2);
CheckValue<IkReal> x610=IKPowWithIntegerCheck(cj3,-1);
if(!x610.valid){
continue;
}
if( IKabs(((x610.value)*((((cj1*cj2*x607))+(((-1.0)*sj1*x604*x607))+(((-1.0)*x604*x608))+(((-1.0)*x605*x609))+((sj1*sj2*x606))+(((-1.0)*cj1*x606*x609)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj1*x606*x609))+(((-1.0)*cj1*x604*x606))+(((-1.0)*x604*x605))+((cj2*x608))+((cj1*sj2*x607))+((cj2*sj1*x607)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x610.value)*((((cj1*cj2*x607))+(((-1.0)*sj1*x604*x607))+(((-1.0)*x604*x608))+(((-1.0)*x605*x609))+((sj1*sj2*x606))+(((-1.0)*cj1*x606*x609))))))+IKsqr(((((-1.0)*sj1*x606*x609))+(((-1.0)*cj1*x604*x606))+(((-1.0)*x604*x605))+((cj2*x608))+((cj1*sj2*x607))+((cj2*sj1*x607))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x610.value)*((((cj1*cj2*x607))+(((-1.0)*sj1*x604*x607))+(((-1.0)*x604*x608))+(((-1.0)*x605*x609))+((sj1*sj2*x606))+(((-1.0)*cj1*x606*x609))))), ((((-1.0)*sj1*x606*x609))+(((-1.0)*cj1*x604*x606))+(((-1.0)*x604*x605))+((cj2*x608))+((cj1*sj2*x607))+((cj2*sj1*x607))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x611=IKsin(j4);
IkReal x612=IKcos(j4);
IkReal x613=((1.0)*cj1);
IkReal x614=(cj0*r01);
IkReal x615=(r00*sj0);
IkReal x616=(cj3*x611);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x611))+((cj0*r00)));
evalcond[1]=(((cj2*x616))+((r02*sj1))+((cj1*x614))+(((-1.0)*x613*x615))+((sj2*x612)));
evalcond[2]=((((-1.0)*sj2*x616))+((sj1*x614))+((cj2*x612))+(((-1.0)*sj1*x615))+(((-1.0)*r02*x613)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}

} else
{
{
IkReal j3array[1], cj3array[1], sj3array[1];
bool j3valid[1]={false};
_nj3 = 1;
IkReal x617=((20795500000000.0)*cj0);
IkReal x618=(cj2*px);
IkReal x619=(cj1*py);
IkReal x620=(pz*sj1);
IkReal x621=((8218800000000.0)*cj0);
IkReal x622=(cj2*py*sj0);
IkReal x623=(cj1*px*sj0);
CheckValue<IkReal> x624=IKPowWithIntegerCheck(IKsign(cj2),-1);
if(!x624.valid){
continue;
}
CheckValue<IkReal> x625 = IKatan2WithCheck(IkReal(((((-20795500000000.0)*x620))+(((-33372200000.0)*cj2))+(((-4678987500000.0)*sj2))+(((-8218800000000.0)*x622))+(((-1.0)*x617*x619))+(((20795500000000.0)*x623))+(((-1.0)*x618*x621)))),IkReal(((((37233100000.0)*cj2))+(((-20795500000000.0)*x622))+(((1849230000000.0)*sj2))+((x619*x621))+(((-8218800000000.0)*x623))+(((8218800000000.0)*x620))+(((-1.0)*x617*x618)))),IKFAST_ATAN2_MAGTHRESH);
if(!x625.valid){
continue;
}
j3array[0]=((-1.5707963267949)+(((1.5707963267949)*(x624.value)))+(x625.value));
sj3array[0]=IKsin(j3array[0]);
cj3array[0]=IKcos(j3array[0]);
if( j3array[0] > IKPI )
{
    j3array[0]-=IK2PI;
}
else if( j3array[0] < -IKPI )
{    j3array[0]+=IK2PI;
}
j3valid[0] = true;
for(int ij3 = 0; ij3 < 1; ++ij3)
{
if( !j3valid[ij3] )
{
    continue;
}
_ij3[0] = ij3; _ij3[1] = -1;
for(int iij3 = ij3+1; iij3 < 1; ++iij3)
{
if( j3valid[iij3] && IKabs(cj3array[ij3]-cj3array[iij3]) < IKFAST_SOLUTION_THRESH && IKabs(sj3array[ij3]-sj3array[iij3]) < IKFAST_SOLUTION_THRESH )
{
    j3valid[iij3]=false; _ij3[1] = iij3; break; 
}
}
j3 = j3array[ij3]; cj3 = cj3array[ij3]; sj3 = sj3array[ij3];
{
IkReal evalcond[3];
IkReal x626=IKsin(j3);
IkReal x627=IKcos(j3);
IkReal x628=((1.0)*cj1);
IkReal x629=(px*sj0);
IkReal x630=(cj0*py);
IkReal x631=((0.00082188)*x627);
IkReal x632=((0.00207955)*x626);
evalcond[0]=((-0.001)+(((0.00207955)*x627))+(((0.00082188)*x626))+((cj0*px))+((py*sj0)));
evalcond[1]=((((-1.0)*x628*x629))+(((0.002)*cj2))+((pz*sj1))+(((-1.0)*cj2*x631))+(((0.225)*sj2))+((cj1*x630))+((cj2*x632)));
evalcond[2]=((0.22)+(((-1.0)*pz*x628))+(((0.225)*cj2))+(((-1.0)*sj1*x629))+((sj2*x631))+(((-0.002)*sj2))+((sj1*x630))+(((-1.0)*sj2*x632)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
IkReal j4eval[1];
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=cj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal j4eval[2];
j4eval[0]=sj3;
j4eval[1]=sj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  || IKabs(j4eval[1]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x633=((1.0)*sj2);
IkReal x634=(r02*sj1);
IkReal x635=(cj0*r01);
IkReal x636=(r00*sj0);
IkReal x637=(cj1*r02);
IkReal x638=((1.0)*cj2);
if( IKabs((((cj1*cj2*x636))+(((-1.0)*cj1*x635*x638))+(((-1.0)*x633*x637))+(((-1.0)*x634*x638))+(((-1.0)*sj1*x633*x636))+((sj1*sj2*x635)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x633*x634))+((cj2*sj1*x636))+(((-1.0)*cj1*x633*x635))+((cj1*sj2*x636))+(((-1.0)*sj1*x635*x638))+((cj2*x637)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*cj2*x636))+(((-1.0)*cj1*x635*x638))+(((-1.0)*x633*x637))+(((-1.0)*x634*x638))+(((-1.0)*sj1*x633*x636))+((sj1*sj2*x635))))+IKsqr(((((-1.0)*x633*x634))+((cj2*sj1*x636))+(((-1.0)*cj1*x633*x635))+((cj1*sj2*x636))+(((-1.0)*sj1*x635*x638))+((cj2*x637))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((cj1*cj2*x636))+(((-1.0)*cj1*x635*x638))+(((-1.0)*x633*x637))+(((-1.0)*x634*x638))+(((-1.0)*sj1*x633*x636))+((sj1*sj2*x635))), ((((-1.0)*x633*x634))+((cj2*sj1*x636))+(((-1.0)*cj1*x633*x635))+((cj1*sj2*x636))+(((-1.0)*sj1*x635*x638))+((cj2*x637))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x639=IKcos(j4);
IkReal x640=IKsin(j4);
IkReal x641=((1.0)*cj1);
IkReal x642=(cj0*r01);
IkReal x643=(r00*sj0);
evalcond[0]=((((-1.0)*x641*x643))+((cj1*x642))+((sj2*x639))+((r02*sj1))+((cj2*x640)));
evalcond[1]=(((sj1*x642))+(((-1.0)*r02*x641))+(((-1.0)*sj2*x640))+(((-1.0)*sj1*x643))+((cj2*x639)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x644=((1.0)*sj2);
IkReal x645=(r02*sj1);
IkReal x646=(cj0*r01);
IkReal x647=((1.0)*cj2);
IkReal x648=(cj1*r02);
IkReal x649=(cj1*r00*sj0);
IkReal x650=(r00*sj0*sj1);
if( IKabs(((((-1.0)*x647*x649))+((cj1*cj2*x646))+((sj2*x650))+((sj2*x648))+((cj2*x645))+(((-1.0)*sj1*x644*x646)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj1*x646*x647))+(((-1.0)*cj1*x644*x646))+((cj2*x650))+(((-1.0)*x644*x645))+((sj2*x649))+((cj2*x648)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*x647*x649))+((cj1*cj2*x646))+((sj2*x650))+((sj2*x648))+((cj2*x645))+(((-1.0)*sj1*x644*x646))))+IKsqr(((((-1.0)*sj1*x646*x647))+(((-1.0)*cj1*x644*x646))+((cj2*x650))+(((-1.0)*x644*x645))+((sj2*x649))+((cj2*x648))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*x647*x649))+((cj1*cj2*x646))+((sj2*x650))+((sj2*x648))+((cj2*x645))+(((-1.0)*sj1*x644*x646))), ((((-1.0)*sj1*x646*x647))+(((-1.0)*cj1*x644*x646))+((cj2*x650))+(((-1.0)*x644*x645))+((sj2*x649))+((cj2*x648))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x651=IKcos(j4);
IkReal x652=IKsin(j4);
IkReal x653=((1.0)*cj1);
IkReal x654=(cj0*r01);
IkReal x655=(r00*sj0);
evalcond[0]=((((-1.0)*cj2*x652))+((cj1*x654))+((r02*sj1))+((sj2*x651))+(((-1.0)*x653*x655)));
evalcond[1]=(((sj1*x654))+((cj2*x651))+((sj2*x652))+(((-1.0)*sj1*x655))+(((-1.0)*r02*x653)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j2))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj2=0;
cj2=1.0;
j2=0;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=0;
cj2=1.0;
j2=0;
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs((((r01*sj0))+((cj0*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj0))+((cj0*r00))))+IKsqr((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r01*sj0))+((cj0*r00))), (((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(((-1.0)*(IKsin(j4))))+((cj0*r00)));
evalcond[1]=((((-1.0)*r00*sj0*sj1))+(IKcos(j4))+((cj0*r01*sj1))+(((-1.0)*cj1*r02)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x656=((1.0)*cj0);
if( IKabs(((((-1.0)*r01*sj0))+(((-1.0)*r00*x656)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*r01*sj1*x656)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj0))+(((-1.0)*r00*x656))))+IKsqr((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*r01*sj1*x656))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*r01*sj0))+(((-1.0)*r00*x656))), (((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*r01*sj1*x656))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(IKsin(j4))+((cj0*r00)));
evalcond[1]=((((-1.0)*r00*sj0*sj1))+(IKcos(j4))+((cj0*r01*sj1))+(((-1.0)*cj1*r02)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x657=(r00*sj0);
IkReal x658=((1.0)*cj0*r01);
if( IKabs(((((-1.0)*cj1*x658))+((cj1*x657))+(((-1.0)*r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj1*x658))+((sj1*x657))+((cj1*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj1*x658))+((cj1*x657))+(((-1.0)*r02*sj1))))+IKsqr(((((-1.0)*sj1*x658))+((sj1*x657))+((cj1*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*cj1*x658))+((cj1*x657))+(((-1.0)*r02*sj1))), ((((-1.0)*sj1*x658))+((sj1*x657))+((cj1*r02))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x659=((1.0)*cj1);
IkReal x660=(cj0*r01);
IkReal x661=(r00*sj0);
evalcond[0]=((((-1.0)*x659*x661))+(IKsin(j4))+((r02*sj1))+((cj1*x660)));
evalcond[1]=(((sj1*x660))+(IKcos(j4))+(((-1.0)*r02*x659))+(((-1.0)*sj1*x661)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x662=(r00*sj0);
IkReal x663=(cj0*r01);
if( IKabs(((((-1.0)*cj1*x662))+((r02*sj1))+((cj1*x663)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((sj1*x662))+((cj1*r02))+(((-1.0)*sj1*x663)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj1*x662))+((r02*sj1))+((cj1*x663))))+IKsqr((((sj1*x662))+((cj1*r02))+(((-1.0)*sj1*x663))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*cj1*x662))+((r02*sj1))+((cj1*x663))), (((sj1*x662))+((cj1*r02))+(((-1.0)*sj1*x663))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x664=((1.0)*cj1);
IkReal x665=(cj0*r01);
IkReal x666=(r00*sj0);
evalcond[0]=(((sj1*x665))+(IKcos(j4))+(((-1.0)*sj1*x666))+(((-1.0)*r02*x664)));
evalcond[1]=((((-1.0)*(IKsin(j4))))+((r02*sj1))+((cj1*x665))+(((-1.0)*x664*x666)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x667=(r00*sj0);
IkReal x668=((1.0)*cj0*r01);
CheckValue<IkReal> x669=IKPowWithIntegerCheck(cj3,-1);
if(!x669.valid){
continue;
}
if( IKabs(((x669.value)*(((((-1.0)*cj1*x668))+(((-1.0)*r02*sj1))+((cj1*x667)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj1*x668))+((sj1*x667))+((cj1*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x669.value)*(((((-1.0)*cj1*x668))+(((-1.0)*r02*sj1))+((cj1*x667))))))+IKsqr(((((-1.0)*sj1*x668))+((sj1*x667))+((cj1*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x669.value)*(((((-1.0)*cj1*x668))+(((-1.0)*r02*sj1))+((cj1*x667))))), ((((-1.0)*sj1*x668))+((sj1*x667))+((cj1*r02))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x670=IKsin(j4);
IkReal x671=((1.0)*cj1);
IkReal x672=(cj0*r01);
IkReal x673=(r00*sj0);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x670))+((cj0*r00)));
evalcond[1]=((((-1.0)*r02*x671))+(((-1.0)*sj1*x673))+(IKcos(j4))+((sj1*x672)));
evalcond[2]=(((cj3*x670))+((r02*sj1))+(((-1.0)*x671*x673))+((cj1*x672)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x674=IKPowWithIntegerCheck(sj3,-1);
if(!x674.valid){
continue;
}
if( IKabs(((x674.value)*((((r01*sj0))+((cj0*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x674.value)*((((r01*sj0))+((cj0*r00))))))+IKsqr((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x674.value)*((((r01*sj0))+((cj0*r00))))), (((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x675=IKsin(j4);
IkReal x676=((1.0)*cj1);
IkReal x677=(cj0*r01);
IkReal x678=(r00*sj0);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x675))+((cj0*r00)));
evalcond[1]=((((-1.0)*r02*x676))+(((-1.0)*sj1*x678))+(IKcos(j4))+((sj1*x677)));
evalcond[2]=(((cj3*x675))+((r02*sj1))+(((-1.0)*x676*x678))+((cj1*x677)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=0;
cj2=-1.0;
j2=3.14159265358979;
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs((((r01*sj0))+((cj0*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj0))+((cj0*r00))))+IKsqr(((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r01*sj0))+((cj0*r00))), ((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(((-1.0)*(IKsin(j4))))+((cj0*r00)));
evalcond[1]=((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*(IKcos(j4))))+(((-1.0)*cj1*r02)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x679=((1.0)*r00);
if( IKabs(((((-1.0)*cj0*x679))+(((-1.0)*r01*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj0*sj1*x679))+((cj0*r01*sj1))+(((-1.0)*cj1*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*cj0*x679))+(((-1.0)*r01*sj0))))+IKsqr(((((-1.0)*sj0*sj1*x679))+((cj0*r01*sj1))+(((-1.0)*cj1*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*cj0*x679))+(((-1.0)*r01*sj0))), ((((-1.0)*sj0*sj1*x679))+((cj0*r01*sj1))+(((-1.0)*cj1*r02))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(IKsin(j4))+((cj0*r00)));
evalcond[1]=((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*(IKcos(j4))))+(((-1.0)*cj1*r02)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x680=((1.0)*cj1);
IkReal x681=(cj0*r01);
IkReal x682=(r00*sj0);
if( IKabs((((cj1*x681))+(((-1.0)*x680*x682))+((r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*sj1*x682))+(((-1.0)*r02*x680))+((sj1*x681)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*x681))+(((-1.0)*x680*x682))+((r02*sj1))))+IKsqr(((((-1.0)*sj1*x682))+(((-1.0)*r02*x680))+((sj1*x681))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((cj1*x681))+(((-1.0)*x680*x682))+((r02*sj1))), ((((-1.0)*sj1*x682))+(((-1.0)*r02*x680))+((sj1*x681))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x683=((1.0)*cj1);
IkReal x684=(cj0*r01);
IkReal x685=(r00*sj0);
evalcond[0]=(((cj1*x684))+(((-1.0)*(IKsin(j4))))+((r02*sj1))+(((-1.0)*x683*x685)));
evalcond[1]=((((-1.0)*sj1*x685))+(((-1.0)*r02*x683))+((sj1*x684))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x686=((1.0)*cj1);
IkReal x687=(cj0*r01);
IkReal x688=((1.0)*sj1);
IkReal x689=(r00*sj0);
if( IKabs((((cj1*x689))+(((-1.0)*r02*x688))+(((-1.0)*x686*x687)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*x688*x689))+(((-1.0)*r02*x686))+((sj1*x687)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*x689))+(((-1.0)*r02*x688))+(((-1.0)*x686*x687))))+IKsqr(((((-1.0)*x688*x689))+(((-1.0)*r02*x686))+((sj1*x687))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((cj1*x689))+(((-1.0)*r02*x688))+(((-1.0)*x686*x687))), ((((-1.0)*x688*x689))+(((-1.0)*r02*x686))+((sj1*x687))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x690=((1.0)*cj1);
IkReal x691=(cj0*r01);
IkReal x692=(r00*sj0);
evalcond[0]=(((cj1*x691))+(IKsin(j4))+((r02*sj1))+(((-1.0)*x690*x692)));
evalcond[1]=(((sj1*x691))+(((-1.0)*sj1*x692))+(((-1.0)*r02*x690))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x693=((1.0)*cj1);
IkReal x694=(cj0*r01);
IkReal x695=(r00*sj0);
CheckValue<IkReal> x696=IKPowWithIntegerCheck(cj3,-1);
if(!x696.valid){
continue;
}
if( IKabs(((x696.value)*((((cj1*x694))+(((-1.0)*x693*x695))+((r02*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((sj1*x694))+(((-1.0)*sj1*x695))+(((-1.0)*r02*x693)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x696.value)*((((cj1*x694))+(((-1.0)*x693*x695))+((r02*sj1))))))+IKsqr((((sj1*x694))+(((-1.0)*sj1*x695))+(((-1.0)*r02*x693))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x696.value)*((((cj1*x694))+(((-1.0)*x693*x695))+((r02*sj1))))), (((sj1*x694))+(((-1.0)*sj1*x695))+(((-1.0)*r02*x693))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x697=IKsin(j4);
IkReal x698=((1.0)*cj1);
IkReal x699=(cj0*r01);
IkReal x700=(r00*sj0);
IkReal x701=((1.0)*x697);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x701))+((cj0*r00)));
evalcond[1]=(((cj1*x699))+((r02*sj1))+(((-1.0)*cj3*x701))+(((-1.0)*x698*x700)));
evalcond[2]=((((-1.0)*sj1*x700))+((sj1*x699))+(((-1.0)*r02*x698))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x702=IKPowWithIntegerCheck(sj3,-1);
if(!x702.valid){
continue;
}
if( IKabs(((x702.value)*((((r01*sj0))+((cj0*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x702.value)*((((r01*sj0))+((cj0*r00))))))+IKsqr(((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x702.value)*((((r01*sj0))+((cj0*r00))))), ((((-1.0)*r00*sj0*sj1))+((cj0*r01*sj1))+(((-1.0)*cj1*r02))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x703=IKsin(j4);
IkReal x704=((1.0)*cj1);
IkReal x705=(cj0*r01);
IkReal x706=(r00*sj0);
IkReal x707=((1.0)*x703);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x707))+((cj0*r00)));
evalcond[1]=(((r02*sj1))+(((-1.0)*cj3*x707))+(((-1.0)*x704*x706))+((cj1*x705)));
evalcond[2]=((((-1.0)*sj1*x706))+(((-1.0)*r02*x704))+((sj1*x705))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=1.0;
cj2=0;
j2=1.5707963267949;
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs((((r01*sj0))+((cj0*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj0))+((cj0*r00))))+IKsqr(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r01*sj0))+((cj0*r00))), ((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(((-1.0)*(IKsin(j4))))+((cj0*r00)));
evalcond[1]=(((cj0*cj1*r01))+((r02*sj1))+(IKcos(j4))+(((-1.0)*cj1*r00*sj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x708=((1.0)*cj0);
if( IKabs(((((-1.0)*r01*sj0))+(((-1.0)*r00*x708)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r02*sj1))+((cj1*r00*sj0))+(((-1.0)*cj1*r01*x708)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj0))+(((-1.0)*r00*x708))))+IKsqr(((((-1.0)*r02*sj1))+((cj1*r00*sj0))+(((-1.0)*cj1*r01*x708))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*r01*sj0))+(((-1.0)*r00*x708))), ((((-1.0)*r02*sj1))+((cj1*r00*sj0))+(((-1.0)*cj1*r01*x708))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(IKsin(j4))+((cj0*r00)));
evalcond[1]=(((cj0*cj1*r01))+((r02*sj1))+(IKcos(j4))+(((-1.0)*cj1*r00*sj0)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x709=((1.0)*cj1);
IkReal x710=(cj0*r01);
IkReal x711=((1.0)*sj1);
IkReal x712=(r00*sj0);
if( IKabs(((((-1.0)*r02*x709))+(((-1.0)*x711*x712))+((sj1*x710)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*r02*x711))+(((-1.0)*x709*x710))+((cj1*x712)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r02*x709))+(((-1.0)*x711*x712))+((sj1*x710))))+IKsqr(((((-1.0)*r02*x711))+(((-1.0)*x709*x710))+((cj1*x712))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*r02*x709))+(((-1.0)*x711*x712))+((sj1*x710))), ((((-1.0)*r02*x711))+(((-1.0)*x709*x710))+((cj1*x712))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x713=((1.0)*cj1);
IkReal x714=(cj0*r01);
IkReal x715=(r00*sj0);
evalcond[0]=(((r02*sj1))+(IKcos(j4))+(((-1.0)*x713*x715))+((cj1*x714)));
evalcond[1]=((((-1.0)*r02*x713))+(((-1.0)*sj1*x715))+(((-1.0)*(IKsin(j4))))+((sj1*x714)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x716=(r00*sj0);
IkReal x717=((1.0)*cj0*r01);
if( IKabs((((cj1*r02))+((sj1*x716))+(((-1.0)*sj1*x717)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj1*x717))+(((-1.0)*r02*sj1))+((cj1*x716)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r02))+((sj1*x716))+(((-1.0)*sj1*x717))))+IKsqr(((((-1.0)*cj1*x717))+(((-1.0)*r02*sj1))+((cj1*x716))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((cj1*r02))+((sj1*x716))+(((-1.0)*sj1*x717))), ((((-1.0)*cj1*x717))+(((-1.0)*r02*sj1))+((cj1*x716))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x718=((1.0)*cj1);
IkReal x719=(cj0*r01);
IkReal x720=(r00*sj0);
evalcond[0]=(((r02*sj1))+(IKcos(j4))+(((-1.0)*x718*x720))+((cj1*x719)));
evalcond[1]=((((-1.0)*r02*x718))+(IKsin(j4))+((sj1*x719))+(((-1.0)*sj1*x720)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x721=((1.0)*cj1);
IkReal x722=(cj0*r01);
IkReal x723=((1.0)*sj1);
IkReal x724=(r00*sj0);
CheckValue<IkReal> x725=IKPowWithIntegerCheck(cj3,-1);
if(!x725.valid){
continue;
}
if( IKabs(((x725.value)*(((((-1.0)*r02*x721))+(((-1.0)*x723*x724))+((sj1*x722)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*x724))+(((-1.0)*r02*x723))+(((-1.0)*x721*x722)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x725.value)*(((((-1.0)*r02*x721))+(((-1.0)*x723*x724))+((sj1*x722))))))+IKsqr((((cj1*x724))+(((-1.0)*r02*x723))+(((-1.0)*x721*x722))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x725.value)*(((((-1.0)*r02*x721))+(((-1.0)*x723*x724))+((sj1*x722))))), (((cj1*x724))+(((-1.0)*r02*x723))+(((-1.0)*x721*x722))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x726=IKsin(j4);
IkReal x727=((1.0)*cj1);
IkReal x728=(cj0*r01);
IkReal x729=(r00*sj0);
IkReal x730=((1.0)*x726);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x730))+((cj0*r00)));
evalcond[1]=(((cj1*x728))+(((-1.0)*x727*x729))+((r02*sj1))+(IKcos(j4)));
evalcond[2]=((((-1.0)*r02*x727))+(((-1.0)*cj3*x730))+((sj1*x728))+(((-1.0)*sj1*x729)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x731=IKPowWithIntegerCheck(sj3,-1);
if(!x731.valid){
continue;
}
if( IKabs(((x731.value)*((((r01*sj0))+((cj0*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x731.value)*((((r01*sj0))+((cj0*r00))))))+IKsqr(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x731.value)*((((r01*sj0))+((cj0*r00))))), ((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x732=IKsin(j4);
IkReal x733=((1.0)*cj1);
IkReal x734=(cj0*r01);
IkReal x735=(r00*sj0);
IkReal x736=((1.0)*x732);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x736))+((cj0*r00)));
evalcond[1]=((((-1.0)*x733*x735))+((r02*sj1))+(IKcos(j4))+((cj1*x734)));
evalcond[2]=((((-1.0)*cj3*x736))+(((-1.0)*r02*x733))+((sj1*x734))+(((-1.0)*sj1*x735)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j2)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j4eval[0]=sj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj2=-1.0;
cj2=0;
j2=-1.5707963267949;
j4eval[0]=cj3;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal evalcond[1];
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
if( IKabs((((r01*sj0))+((cj0*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj0))+((cj0*r00))))+IKsqr((((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r01*sj0))+((cj0*r00))), (((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(((-1.0)*(IKsin(j4))))+((cj0*r00)));
evalcond[1]=(((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x737=((1.0)*r00);
if( IKabs(((((-1.0)*r01*sj0))+(((-1.0)*cj0*x737)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj1*sj0*x737))+((cj0*cj1*r01))+((r02*sj1)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj0))+(((-1.0)*cj0*x737))))+IKsqr(((((-1.0)*cj1*sj0*x737))+((cj0*cj1*r01))+((r02*sj1))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*r01*sj0))+(((-1.0)*cj0*x737))), ((((-1.0)*cj1*sj0*x737))+((cj0*cj1*r01))+((r02*sj1))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
evalcond[0]=(((r01*sj0))+(IKsin(j4))+((cj0*r00)));
evalcond[1]=(((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(j3))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x738=(r00*sj0);
IkReal x739=(cj0*r01);
if( IKabs((((cj1*r02))+((sj1*x738))+(((-1.0)*sj1*x739)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((((-1.0)*cj1*x738))+((r02*sj1))+((cj1*x739)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((cj1*r02))+((sj1*x738))+(((-1.0)*sj1*x739))))+IKsqr(((((-1.0)*cj1*x738))+((r02*sj1))+((cj1*x739))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((cj1*r02))+((sj1*x738))+(((-1.0)*sj1*x739))), ((((-1.0)*cj1*x738))+((r02*sj1))+((cj1*x739))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x740=((1.0)*cj1);
IkReal x741=(cj0*r01);
IkReal x742=(r00*sj0);
evalcond[0]=((((-1.0)*sj1*x742))+(IKsin(j4))+((sj1*x741))+(((-1.0)*r02*x740)));
evalcond[1]=(((cj1*x741))+((r02*sj1))+(((-1.0)*x740*x742))+(((-1.0)*(IKcos(j4)))));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-3.14159265358979)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x743=((1.0)*cj1);
IkReal x744=(cj0*r01);
IkReal x745=(r00*sj0);
if( IKabs(((((-1.0)*sj1*x745))+((sj1*x744))+(((-1.0)*r02*x743)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*x744))+((r02*sj1))+(((-1.0)*x743*x745)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*sj1*x745))+((sj1*x744))+(((-1.0)*r02*x743))))+IKsqr((((cj1*x744))+((r02*sj1))+(((-1.0)*x743*x745))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*sj1*x745))+((sj1*x744))+(((-1.0)*r02*x743))), (((cj1*x744))+((r02*sj1))+(((-1.0)*x743*x745))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[2];
IkReal x746=((1.0)*cj1);
IkReal x747=(cj0*r01);
IkReal x748=(r00*sj0);
evalcond[0]=(((cj1*x747))+(((-1.0)*x746*x748))+((r02*sj1))+(((-1.0)*(IKcos(j4)))));
evalcond[1]=((((-1.0)*(IKsin(j4))))+(((-1.0)*sj1*x748))+((sj1*x747))+(((-1.0)*r02*x746)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x749=(r00*sj0);
IkReal x750=(cj0*r01);
CheckValue<IkReal> x751=IKPowWithIntegerCheck(cj3,-1);
if(!x751.valid){
continue;
}
if( IKabs(((x751.value)*((((cj1*r02))+(((-1.0)*sj1*x750))+((sj1*x749)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*x750))+((r02*sj1))+(((-1.0)*cj1*x749)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x751.value)*((((cj1*r02))+(((-1.0)*sj1*x750))+((sj1*x749))))))+IKsqr((((cj1*x750))+((r02*sj1))+(((-1.0)*cj1*x749))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x751.value)*((((cj1*r02))+(((-1.0)*sj1*x750))+((sj1*x749))))), (((cj1*x750))+((r02*sj1))+(((-1.0)*cj1*x749))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x752=IKsin(j4);
IkReal x753=((1.0)*cj1);
IkReal x754=(cj0*r01);
IkReal x755=(r00*sj0);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x752))+((cj0*r00)));
evalcond[1]=(((cj1*x754))+(((-1.0)*x753*x755))+((r02*sj1))+(((-1.0)*(IKcos(j4)))));
evalcond[2]=((((-1.0)*sj1*x755))+(((-1.0)*r02*x753))+((sj1*x754))+((cj3*x752)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x756=IKPowWithIntegerCheck(sj3,-1);
if(!x756.valid){
continue;
}
if( IKabs(((x756.value)*((((r01*sj0))+((cj0*r00)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x756.value)*((((r01*sj0))+((cj0*r00))))))+IKsqr((((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x756.value)*((((r01*sj0))+((cj0*r00))))), (((cj0*cj1*r01))+((r02*sj1))+(((-1.0)*cj1*r00*sj0))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x757=IKsin(j4);
IkReal x758=((1.0)*cj1);
IkReal x759=(cj0*r01);
IkReal x760=(r00*sj0);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x757))+((cj0*r00)));
evalcond[1]=((((-1.0)*x758*x760))+((cj1*x759))+((r02*sj1))+(((-1.0)*(IKcos(j4)))));
evalcond[2]=((((-1.0)*sj1*x760))+(((-1.0)*r02*x758))+((sj1*x759))+((cj3*x757)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((-1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
j4eval[0]=cj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj3=1.0;
cj3=0;
j3=1.5707963267949;
j4eval[0]=sj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x761=IKPowWithIntegerCheck(sj2,-1);
if(!x761.valid){
continue;
}
if( IKabs((((r01*sj0))+((cj0*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x761.value)*(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj0))+((cj0*r00))))+IKsqr(((x761.value)*(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r01*sj0))+((cj0*r00))), ((x761.value)*(((((-1.0)*cj0*cj1*r01))+(((-1.0)*r02*sj1))+((cj1*r00*sj0))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x762=IKcos(j4);
IkReal x763=((1.0)*cj1);
IkReal x764=(cj0*r01);
IkReal x765=(r00*sj0);
evalcond[0]=(((r01*sj0))+(((-1.0)*(IKsin(j4))))+((cj0*r00)));
evalcond[1]=(((cj1*x764))+(((-1.0)*x763*x765))+((sj2*x762))+((r02*sj1)));
evalcond[2]=(((cj2*x762))+(((-1.0)*sj1*x765))+((sj1*x764))+(((-1.0)*r02*x763)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x766=IKPowWithIntegerCheck(cj2,-1);
if(!x766.valid){
continue;
}
if( IKabs((((r01*sj0))+((cj0*r00)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x766.value)*((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((((r01*sj0))+((cj0*r00))))+IKsqr(((x766.value)*((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((((r01*sj0))+((cj0*r00))), ((x766.value)*((((r00*sj0*sj1))+((cj1*r02))+(((-1.0)*cj0*r01*sj1))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x767=IKcos(j4);
IkReal x768=((1.0)*cj1);
IkReal x769=(cj0*r01);
IkReal x770=(r00*sj0);
evalcond[0]=(((r01*sj0))+(((-1.0)*(IKsin(j4))))+((cj0*r00)));
evalcond[1]=((((-1.0)*x768*x770))+((cj1*x769))+((sj2*x767))+((r02*sj1)));
evalcond[2]=(((cj2*x767))+(((-1.0)*sj1*x770))+((sj1*x769))+(((-1.0)*r02*x768)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
evalcond[0]=((-3.14159265358979)+(IKfmod(((3.14159265358979)+(IKabs(((1.5707963267949)+j3)))), 6.28318530717959)));
if( IKabs(evalcond[0]) < 0.0000050000000000  )
{
bgotonextstatement=false;
{
IkReal j4eval[1];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
j4eval[0]=cj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
{
IkReal j4eval[1];
sj3=-1.0;
cj3=0;
j3=-1.5707963267949;
j4eval[0]=sj2;
if( IKabs(j4eval[0]) < 0.0000010000000000  )
{
continue; // no branches [j4]

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x771=((1.0)*cj0);
CheckValue<IkReal> x772=IKPowWithIntegerCheck(sj2,-1);
if(!x772.valid){
continue;
}
if( IKabs(((((-1.0)*r01*sj0))+(((-1.0)*r00*x771)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x772.value)*(((((-1.0)*r02*sj1))+(((-1.0)*cj1*r01*x771))+((cj1*r00*sj0)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj0))+(((-1.0)*r00*x771))))+IKsqr(((x772.value)*(((((-1.0)*r02*sj1))+(((-1.0)*cj1*r01*x771))+((cj1*r00*sj0))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*r01*sj0))+(((-1.0)*r00*x771))), ((x772.value)*(((((-1.0)*r02*sj1))+(((-1.0)*cj1*r01*x771))+((cj1*r00*sj0))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x773=IKcos(j4);
IkReal x774=((1.0)*cj1);
IkReal x775=(cj0*r01);
IkReal x776=(r00*sj0);
evalcond[0]=(((r01*sj0))+(IKsin(j4))+((cj0*r00)));
evalcond[1]=((((-1.0)*x774*x776))+((cj1*x775))+((r02*sj1))+((sj2*x773)));
evalcond[2]=((((-1.0)*sj1*x776))+((cj2*x773))+(((-1.0)*r02*x774))+((sj1*x775)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x777=((1.0)*cj0);
CheckValue<IkReal> x778=IKPowWithIntegerCheck(cj2,-1);
if(!x778.valid){
continue;
}
if( IKabs(((((-1.0)*r01*sj0))+(((-1.0)*r00*x777)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(((x778.value)*((((r00*sj0*sj1))+(((-1.0)*r01*sj1*x777))+((cj1*r02)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((((-1.0)*r01*sj0))+(((-1.0)*r00*x777))))+IKsqr(((x778.value)*((((r00*sj0*sj1))+(((-1.0)*r01*sj1*x777))+((cj1*r02))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((((-1.0)*r01*sj0))+(((-1.0)*r00*x777))), ((x778.value)*((((r00*sj0*sj1))+(((-1.0)*r01*sj1*x777))+((cj1*r02))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x779=IKcos(j4);
IkReal x780=((1.0)*cj1);
IkReal x781=(cj0*r01);
IkReal x782=(r00*sj0);
evalcond[0]=(((r01*sj0))+(IKsin(j4))+((cj0*r00)));
evalcond[1]=(((cj1*x781))+((r02*sj1))+((sj2*x779))+(((-1.0)*x780*x782)));
evalcond[2]=(((sj1*x781))+((cj2*x779))+(((-1.0)*r02*x780))+(((-1.0)*sj1*x782)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

}
} while(0);
if( bgotonextstatement )
{
bool bgotonextstatement = true;
do
{
if( 1 )
{
bgotonextstatement=false;
continue; // branch miss [j4]

}
} while(0);
if( bgotonextstatement )
{
}
}
}
}
}
}
}
}
}
}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x788=IKPowWithIntegerCheck(sj3,-1);
if(!x788.valid){
continue;
}
IkReal x783=x788.value;
IkReal x784=(cj1*sj3);
IkReal x785=((1.0)*r01);
IkReal x786=(cj2*cj3);
IkReal x787=(cj0*r00);
CheckValue<IkReal> x789=IKPowWithIntegerCheck(sj2,-1);
if(!x789.valid){
continue;
}
if( IKabs((x783*((((r01*sj0))+x787)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x783*(x789.value)*(((((-1.0)*r02*sj1*sj3))+(((-1.0)*sj0*x785*x786))+(((-1.0)*cj0*x784*x785))+(((-1.0)*x786*x787))+((r00*sj0*x784)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x783*((((r01*sj0))+x787))))+IKsqr((x783*(x789.value)*(((((-1.0)*r02*sj1*sj3))+(((-1.0)*sj0*x785*x786))+(((-1.0)*cj0*x784*x785))+(((-1.0)*x786*x787))+((r00*sj0*x784))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x783*((((r01*sj0))+x787))), (x783*(x789.value)*(((((-1.0)*r02*sj1*sj3))+(((-1.0)*sj0*x785*x786))+(((-1.0)*cj0*x784*x785))+(((-1.0)*x786*x787))+((r00*sj0*x784))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x790=IKsin(j4);
IkReal x791=IKcos(j4);
IkReal x792=((1.0)*cj1);
IkReal x793=(cj0*r01);
IkReal x794=(r00*sj0);
IkReal x795=(cj3*x790);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x790))+((cj0*r00)));
evalcond[1]=((((-1.0)*x792*x794))+((cj1*x793))+((r02*sj1))+((cj2*x795))+((sj2*x791)));
evalcond[2]=((((-1.0)*sj2*x795))+((sj1*x793))+(((-1.0)*r02*x792))+((cj2*x791))+(((-1.0)*sj1*x794)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
CheckValue<IkReal> x801=IKPowWithIntegerCheck(sj3,-1);
if(!x801.valid){
continue;
}
IkReal x796=x801.value;
IkReal x797=(sj1*sj3);
IkReal x798=(cj0*r00);
IkReal x799=(r01*sj0);
IkReal x800=(cj3*sj2);
CheckValue<IkReal> x802=IKPowWithIntegerCheck(cj2,-1);
if(!x802.valid){
continue;
}
if( IKabs((x796*((x799+x798)))) < IKFAST_ATAN2_MAGTHRESH && IKabs((x796*(x802.value)*(((((-1.0)*cj0*r01*x797))+((x798*x800))+((x799*x800))+((r00*sj0*x797))+((cj1*r02*sj3)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr((x796*((x799+x798))))+IKsqr((x796*(x802.value)*(((((-1.0)*cj0*r01*x797))+((x798*x800))+((x799*x800))+((r00*sj0*x797))+((cj1*r02*sj3))))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2((x796*((x799+x798))), (x796*(x802.value)*(((((-1.0)*cj0*r01*x797))+((x798*x800))+((x799*x800))+((r00*sj0*x797))+((cj1*r02*sj3))))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x803=IKsin(j4);
IkReal x804=IKcos(j4);
IkReal x805=((1.0)*cj1);
IkReal x806=(cj0*r01);
IkReal x807=(r00*sj0);
IkReal x808=(cj3*x803);
evalcond[0]=(((r01*sj0))+(((-1.0)*sj3*x803))+((cj0*r00)));
evalcond[1]=(((sj2*x804))+(((-1.0)*x805*x807))+((cj1*x806))+((r02*sj1))+((cj2*x808)));
evalcond[2]=((((-1.0)*sj1*x807))+(((-1.0)*r02*x805))+((cj2*x804))+((sj1*x806))+(((-1.0)*sj2*x808)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}

} else
{
{
IkReal j4array[1], cj4array[1], sj4array[1];
bool j4valid[1]={false};
_nj4 = 1;
IkReal x809=((1.0)*sj2);
IkReal x810=(r02*sj1);
IkReal x811=(cj0*r01);
IkReal x812=(r00*sj0);
IkReal x813=(cj1*r02);
IkReal x814=((1.0)*cj2);
CheckValue<IkReal> x815=IKPowWithIntegerCheck(cj3,-1);
if(!x815.valid){
continue;
}
if( IKabs(((x815.value)*((((sj1*sj2*x811))+(((-1.0)*x809*x813))+(((-1.0)*sj1*x809*x812))+(((-1.0)*x810*x814))+((cj1*cj2*x812))+(((-1.0)*cj1*x811*x814)))))) < IKFAST_ATAN2_MAGTHRESH && IKabs((((cj1*sj2*x812))+(((-1.0)*sj1*x811*x814))+(((-1.0)*x809*x810))+(((-1.0)*cj1*x809*x811))+((cj2*sj1*x812))+((cj2*x813)))) < IKFAST_ATAN2_MAGTHRESH && IKabs(IKsqr(((x815.value)*((((sj1*sj2*x811))+(((-1.0)*x809*x813))+(((-1.0)*sj1*x809*x812))+(((-1.0)*x810*x814))+((cj1*cj2*x812))+(((-1.0)*cj1*x811*x814))))))+IKsqr((((cj1*sj2*x812))+(((-1.0)*sj1*x811*x814))+(((-1.0)*x809*x810))+(((-1.0)*cj1*x809*x811))+((cj2*sj1*x812))+((cj2*x813))))-1) <= IKFAST_SINCOS_THRESH )
    continue;
j4array[0]=IKatan2(((x815.value)*((((sj1*sj2*x811))+(((-1.0)*x809*x813))+(((-1.0)*sj1*x809*x812))+(((-1.0)*x810*x814))+((cj1*cj2*x812))+(((-1.0)*cj1*x811*x814))))), (((cj1*sj2*x812))+(((-1.0)*sj1*x811*x814))+(((-1.0)*x809*x810))+(((-1.0)*cj1*x809*x811))+((cj2*sj1*x812))+((cj2*x813))));
sj4array[0]=IKsin(j4array[0]);
cj4array[0]=IKcos(j4array[0]);
if( j4array[0] > IKPI )
{
    j4array[0]-=IK2PI;
}
else if( j4array[0] < -IKPI )
{    j4array[0]+=IK2PI;
}
j4valid[0] = true;
for(int ij4 = 0; ij4 < 1; ++ij4)
{
if( !j4valid[ij4] )
{
    continue;
}
_ij4[0] = ij4; _ij4[1] = -1;
for(int iij4 = ij4+1; iij4 < 1; ++iij4)
{
if( j4valid[iij4] && IKabs(cj4array[ij4]-cj4array[iij4]) < IKFAST_SOLUTION_THRESH && IKabs(sj4array[ij4]-sj4array[iij4]) < IKFAST_SOLUTION_THRESH )
{
    j4valid[iij4]=false; _ij4[1] = iij4; break; 
}
}
j4 = j4array[ij4]; cj4 = cj4array[ij4]; sj4 = sj4array[ij4];
{
IkReal evalcond[3];
IkReal x816=IKsin(j4);
IkReal x817=IKcos(j4);
IkReal x818=((1.0)*cj1);
IkReal x819=(cj0*r01);
IkReal x820=(r00*sj0);
IkReal x821=(cj3*x816);
evalcond[0]=(((r01*sj0))+((cj0*r00))+(((-1.0)*sj3*x816)));
evalcond[1]=((((-1.0)*x818*x820))+((r02*sj1))+((sj2*x817))+((cj1*x819))+((cj2*x821)));
evalcond[2]=((((-1.0)*sj2*x821))+((sj1*x819))+(((-1.0)*sj1*x820))+(((-1.0)*r02*x818))+((cj2*x817)));
if( IKabs(evalcond[0]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[1]) > IKFAST_EVALCOND_THRESH  || IKabs(evalcond[2]) > IKFAST_EVALCOND_THRESH  )
{
continue;
}
}

{
std::vector<IkSingleDOFSolutionBase<IkReal> > vinfos(5);
vinfos[0].jointtype = 1;
vinfos[0].foffset = j0;
vinfos[0].indices[0] = _ij0[0];
vinfos[0].indices[1] = _ij0[1];
vinfos[0].maxsolutions = _nj0;
vinfos[1].jointtype = 1;
vinfos[1].foffset = j1;
vinfos[1].indices[0] = _ij1[0];
vinfos[1].indices[1] = _ij1[1];
vinfos[1].maxsolutions = _nj1;
vinfos[2].jointtype = 1;
vinfos[2].foffset = j2;
vinfos[2].indices[0] = _ij2[0];
vinfos[2].indices[1] = _ij2[1];
vinfos[2].maxsolutions = _nj2;
vinfos[3].jointtype = 1;
vinfos[3].foffset = j3;
vinfos[3].indices[0] = _ij3[0];
vinfos[3].indices[1] = _ij3[1];
vinfos[3].maxsolutions = _nj3;
vinfos[4].jointtype = 1;
vinfos[4].foffset = j4;
vinfos[4].indices[0] = _ij4[0];
vinfos[4].indices[1] = _ij4[1];
vinfos[4].maxsolutions = _nj4;
std::vector<int> vfree(0);
solutions.AddSolution(vinfos,vfree);
}
}
}

}

}
}
}

}

}
}
}
// [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1), (3, 0), (3, 1)] (original are [(0, 0), (0, 1), (1, 0), (1, 1), (2, 0), (2, 1)])
static inline bool checkconsistency8(const IkReal* Breal)
{
    IkReal norm = 0.1;
    for(int i = 0; i < 7; ++i) {
        norm += IKabs(Breal[i]);
    }
    // HACK should be 1e-5*norm
    IkReal tol = 1e-2*norm; // have to increase the threshold since many computations are involved
    return IKabs(Breal[0]*Breal[1]-Breal[2]) < tol && IKabs(Breal[1]*Breal[1]-Breal[3]) < tol && IKabs(Breal[0]*Breal[3]-Breal[4]) < tol && IKabs(Breal[1]*Breal[3]-Breal[5]) < tol && IKabs(Breal[0]*Breal[5]-Breal[6]) < tol;
}
/// \brief Solve the det Ax^2+Bx+C = 0 problem using the Manocha and Canny method (1994)
///
/// matcoeffs is of length 54*3, for 3 matrices
static inline void solvedialyticpoly8qep(const IkReal* matcoeffs, IkReal* rawroots, int& numroots)
{
    const IkReal tol = 128.0*std::numeric_limits<IkReal>::epsilon();
    IkReal IKFAST_ALIGNED16(M[16*16]) = {0};
    IkReal IKFAST_ALIGNED16(A[8*8]);
    IkReal IKFAST_ALIGNED16(work[16*16*15]);
    int ipiv[8];
    int info, coeffindex;
    const int worksize=16*16*15;
    const int matrixdim = 8;
    const int matrixdim2 = 16;
    numroots = 0;
    // first setup M = [0 I; -C -B] and A
    coeffindex = 0;
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -matcoeffs[coeffindex++];
        }
    }
    for(int j = 0; j < 4; ++j) {
        for(int k = 0; k < 6; ++k) {
            A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = matcoeffs[coeffindex++];
        }
        for(int k = 0; k < 2; ++k) {
            A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
        }
    }
    const IkReal lfpossibilities[4][4] = {{1,-1,1,1},{1,0,-2,1},{1,1,2,0},{1,-1,4,1}};
    int lfindex = -1;
    bool bsingular = true;
    do {
        dgetrf_(&matrixdim,&matrixdim,A,&matrixdim,&ipiv[0],&info);
        if( info == 0 ) {
            bsingular = false;
            for(int j = 0; j < matrixdim; ++j) {
                if( IKabs(A[j*matrixdim+j]) < 100*tol ) {
                    bsingular = true;
                    break;
                }
            }
            if( !bsingular ) {
                break;
            }
        }
        if( lfindex == 3 ) {
            break;
        }
        // transform by the linear functional
        lfindex++;
        const IkReal* lf = lfpossibilities[lfindex];
        // have to reinitialize A
        coeffindex = 0;
        for(int j = 0; j < 4; ++j) {
            for(int k = 0; k < 6; ++k) {
                IkReal a = matcoeffs[coeffindex+48], b = matcoeffs[coeffindex+24], c = matcoeffs[coeffindex];
                A[(j+4)+matrixdim*k] = A[j+matrixdim*(k+2)] = lf[0]*lf[0]*a+lf[0]*lf[2]*b+lf[2]*lf[2]*c;
                M[matrixdim+(j+4)+2*matrixdim*k] = M[matrixdim+j+2*matrixdim*(k+2)] = -(lf[1]*lf[1]*a + lf[1]*lf[3]*b + lf[3]*lf[3]*c);
                M[matrixdim+(j+4)+2*matrixdim*k+matrixdim*2*matrixdim] = M[matrixdim+j+2*matrixdim*(k+2)+matrixdim*2*matrixdim] = -(2*lf[0]*lf[1]*a + (lf[0]*lf[3]+lf[1]*lf[2])*b + 2*lf[2]*lf[3]*c);
                coeffindex++;
            }
            for(int k = 0; k < 2; ++k) {
                A[j+matrixdim*k] = A[(j+4)+matrixdim*(k+6)] = 0;
            }
        }
    } while(lfindex<4);

    if( bsingular ) {
        return;
    }
    dgetrs_("No transpose", &matrixdim, &matrixdim2, A, &matrixdim, &ipiv[0], &M[matrixdim], &matrixdim2, &info);
    if( info != 0 ) {
        return;
    }

    // set identity in upper corner
    for(int j = 0; j < matrixdim; ++j) {
        M[matrixdim*2*matrixdim+j+matrixdim*2*j] = 1;
    }
    IkReal IKFAST_ALIGNED16(wr[16]);
    IkReal IKFAST_ALIGNED16(wi[16]);
    IkReal IKFAST_ALIGNED16(vr[16*16]);
    int one=1;
    dgeev_("N", "V", &matrixdim2, M, &matrixdim2, wr, wi,NULL, &one, vr, &matrixdim2, work, &worksize, &info);
    if( info != 0 ) {
        return;
    }
    IkReal Breal[matrixdim-1];
    for(int i = 0; i < matrixdim2; ++i) {
        // HACK should be tol*100
        if( IKabs(wi[i]) < 5e-5 ) {
            IkReal* ev = vr+matrixdim2*i;
            if( IKabs(wr[i]) > 1 ) {
                ev += matrixdim;
            }
            // consistency has to be checked!!
            if( IKabs(ev[0]) < tol ) {
                continue;
            }
            IkReal iconst = 1/ev[0];
            for(int j = 1; j < matrixdim; ++j) {
                Breal[j-1] = ev[j]*iconst;
            }
            if( checkconsistency8(Breal) ) {
                if( lfindex >= 0 ) {
                    const IkReal* lf = lfpossibilities[lfindex];
                    rawroots[numroots++] = (wr[i]*lf[0]+lf[1])/(wr[i]*lf[2]+lf[3]);
                }
                else {
                    rawroots[numroots++] = wr[i];
                }
                bool bsmall0=IKabs(ev[0]) > IKabs(ev[2]);
                bool bsmall1=IKabs(ev[0]) > IKabs(ev[1]);
                if( bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[2]/ev[0];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[3]/ev[1];
                    rawroots[numroots++] = ev[1]/ev[0];
                }
                else if( !bsmall0 && bsmall1 ) {
                    rawroots[numroots++] = ev[6]/ev[4];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
                else if( !bsmall0 && !bsmall1 ) {
                    rawroots[numroots++] = ev[7]/ev[5];
                    rawroots[numroots++] = ev[7]/ev[6];
                }
            }
        }
    }
}};


/// solves the inverse kinematics equations.
/// \param pfree is an array specifying the free joints of the chain.
IKFAST_API bool ComputeIk(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API bool ComputeIk2(const IkReal* eetrans, const IkReal* eerot, const IkReal* pfree, IkSolutionListBase<IkReal>& solutions, void* pOpenRAVEManip) {
IKSolver solver;
return solver.ComputeIk(eetrans,eerot,pfree,solutions);
}

IKFAST_API const char* GetKinematicsHash() { return "9fb69b584096b8e48094cd1ca0c1cfd5"; }

IKFAST_API const char* GetIkFastVersion() { return "0x1000004a"; }

#ifdef IKFAST_NAMESPACE
} // end namespace
#endif

#ifndef IKFAST_NO_MAIN
#include <stdio.h>
#include <stdlib.h>
#ifdef IKFAST_NAMESPACE
using namespace IKFAST_NAMESPACE;
#endif
int main(int argc, char** argv)
{
    if( argc != 12+GetNumFreeParameters()+1 ) {
        printf("\nUsage: ./ik r00 r01 r02 t0 r10 r11 r12 t1 r20 r21 r22 t2 free0 ...\n\n"
               "Returns the ik solutions given the transformation of the end effector specified by\n"
               "a 3x3 rotation R (rXX), and a 3x1 translation (tX).\n"
               "There are %d free parameters that have to be specified.\n\n",GetNumFreeParameters());
        return 1;
    }

    IkSolutionList<IkReal> solutions;
    std::vector<IkReal> vfree(GetNumFreeParameters());
    IkReal eerot[9],eetrans[3];
    eerot[0] = atof(argv[1]); eerot[1] = atof(argv[2]); eerot[2] = atof(argv[3]); eetrans[0] = atof(argv[4]);
    eerot[3] = atof(argv[5]); eerot[4] = atof(argv[6]); eerot[5] = atof(argv[7]); eetrans[1] = atof(argv[8]);
    eerot[6] = atof(argv[9]); eerot[7] = atof(argv[10]); eerot[8] = atof(argv[11]); eetrans[2] = atof(argv[12]);
    for(std::size_t i = 0; i < vfree.size(); ++i)
        vfree[i] = atof(argv[13+i]);
    bool bSuccess = ComputeIk(eetrans, eerot, vfree.size() > 0 ? &vfree[0] : NULL, solutions);

    if( !bSuccess ) {
        fprintf(stderr,"Failed to get ik solution\n");
        return -1;
    }

    printf("Found %d ik solutions:\n", (int)solutions.GetNumSolutions());
    std::vector<IkReal> solvalues(GetNumJoints());
    for(std::size_t i = 0; i < solutions.GetNumSolutions(); ++i) {
        const IkSolutionBase<IkReal>& sol = solutions.GetSolution(i);
        printf("sol%d (free=%d): ", (int)i, (int)sol.GetFree().size());
        std::vector<IkReal> vsolfree(sol.GetFree().size());
        sol.GetSolution(&solvalues[0],vsolfree.size()>0?&vsolfree[0]:NULL);
        for( std::size_t j = 0; j < solvalues.size(); ++j)
            printf("%.15f, ", solvalues[j]);
        printf("\n");
    }
    return 0;
}

#endif
